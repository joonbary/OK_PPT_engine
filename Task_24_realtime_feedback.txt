# 🎯 사용자 편의성 강화 - 전체 구현 계획서

완벽합니다! 4주 계획을 상세 작업지시서로 만들어드리겠습니다.

---

## 📅 전체 타임라인 (4주)

```
Week 1: 즉시 체감 개선 (실시간 피드백)
├── Day 1-2: WebSocket 인프라 + 진행률 표시
├── Day 3-4: 슬라이드 프리뷰 시스템
└── Day 5: 원클릭 스타일 변경

Week 2: 발표 준비 지원
├── Day 1-2: AI 발표자 노트 생성
├── Day 3-4: 예상 질문 + 답변 생성
└── Day 5: 스피커 노트 PPT 삽입

Week 3: 스마트 편집 기능
├── Day 1-2: 슬라이드 추가/삭제/재배열
├── Day 3-4: 자연어 편집 명령 파서
└── Day 5: 편집 명령 실행 엔진

Week 4: 버전 관리 + 통합
├── Day 1-2: 버전 관리 시스템
├── Day 3: 버전 비교 뷰
├── Day 4: 통합 테스트
└── Day 5: 문서화 + 배포
```

---

# 📋 Week 1: 즉시 체감 개선

## Task 1.1: WebSocket 인프라 구축 (Day 1)

### 파일: `app/core/websocket_manager.py` (신규)

```python
"""
WebSocket 연결 관리 및 실시간 메시지 브로드캐스팅
"""

from fastapi import WebSocket
from typing import Dict, List
import asyncio
import json

class ConnectionManager:
    """WebSocket 연결 관리자"""
    
    def __init__(self):
        # ppt_id별 활성 연결 관리
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, ppt_id: str):
        """클라이언트 연결"""
        await websocket.accept()
        
        if ppt_id not in self.active_connections:
            self.active_connections[ppt_id] = []
        
        self.active_connections[ppt_id].append(websocket)
    
    def disconnect(self, websocket: WebSocket, ppt_id: str):
        """클라이언트 연결 해제"""
        if ppt_id in self.active_connections:
            self.active_connections[ppt_id].remove(websocket)
            
            # 연결이 없으면 키 삭제
            if not self.active_connections[ppt_id]:
                del self.active_connections[ppt_id]
    
    async def broadcast(self, ppt_id: str, message: Dict):
        """특정 PPT 작업의 모든 클라이언트에 메시지 전송"""
        if ppt_id not in self.active_connections:
            return
        
        dead_connections = []
        
        for connection in self.active_connections[ppt_id]:
            try:
                await connection.send_json(message)
            except Exception:
                dead_connections.append(connection)
        
        # 끊긴 연결 제거
        for dead in dead_connections:
            self.disconnect(dead, ppt_id)

# 전역 인스턴스
manager = ConnectionManager()
```

### 파일: `app/api/websocket.py` (신규)

```python
"""
WebSocket 엔드포인트
"""

from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from app.core.websocket_manager import manager

router = APIRouter()

@router.websocket("/ws/progress/{ppt_id}")
async def websocket_endpoint(websocket: WebSocket, ppt_id: str):
    """
    실시간 진행 상황 스트리밍
    
    클라이언트 사용법:
    const ws = new WebSocket('ws://localhost:8000/ws/progress/abc123');
    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        console.log(data.stage, data.progress);
    };
    """
    
    await manager.connect(websocket, ppt_id)
    
    try:
        # 연결 유지 (메시지는 백그라운드 작업에서 전송)
        while True:
            # 클라이언트 핑 대기
            await websocket.receive_text()
            
    except WebSocketDisconnect:
        manager.disconnect(websocket, ppt_id)
```

### 파일: `app/api/router.py` (수정)

```python
# WebSocket 라우터 추가
from app.api import websocket

app.include_router(websocket.router, tags=["websocket"])
```

---

## Task 1.2: 진행률 추적 시스템 (Day 2)

### 파일: `app/services/progress_tracker.py` (신규)

```python
"""
작업 진행률 추적 및 WebSocket 알림
"""

from app.core.websocket_manager import manager
from typing import Dict, Optional
import asyncio

class ProgressTracker:
    """진행률 추적 및 알림"""
    
    # 각 스테이지별 가중치 (총 100%)
    STAGE_WEIGHTS = {
        "document_analysis": 15,
        "structure_design": 20,
        "content_generation": 30,
        "design_application": 25,
        "quality_review": 10
    }
    
    STAGE_NAMES_KR = {
        "document_analysis": "📄 문서 분석 중",
        "structure_design": "🏗️ 구조 설계 중",
        "content_generation": "✍️ 콘텐츠 생성 중",
        "design_application": "🎨 디자인 적용 중",
        "quality_review": "✅ 품질 검증 중"
    }
    
    def __init__(self, ppt_id: str):
        self.ppt_id = ppt_id
        self.current_progress = 0
        self.current_stage = None
        self.stage_start_progress = 0
    
    async def start_stage(self, stage: str):
        """스테이지 시작 알림"""
        self.current_stage = stage
        self.stage_start_progress = self.current_progress
        
        await self._send_update(
            stage=self.STAGE_NAMES_KR[stage],
            status="started",
            message=f"{self.STAGE_NAMES_KR[stage]} 시작"
        )
    
    async def update_progress(self, stage_progress: float):
        """
        스테이지 내 진행률 업데이트
        
        Args:
            stage_progress: 0.0 ~ 1.0 (현재 스테이지 진행률)
        """
        if not self.current_stage:
            return
        
        stage_weight = self.STAGE_WEIGHTS[self.current_stage]
        added_progress = stage_weight * stage_progress
        
        self.current_progress = self.stage_start_progress + added_progress
        
        await self._send_update(
            stage=self.STAGE_NAMES_KR[self.current_stage],
            status="in_progress",
            progress=round(self.current_progress, 1)
        )
    
    async def complete_stage(self):
        """스테이지 완료"""
        if not self.current_stage:
            return
        
        stage_weight = self.STAGE_WEIGHTS[self.current_stage]
        self.current_progress = self.stage_start_progress + stage_weight
        
        await self._send_update(
            stage=self.STAGE_NAMES_KR[self.current_stage],
            status="completed",
            progress=round(self.current_progress, 1),
            message=f"{self.STAGE_NAMES_KR[self.current_stage]} 완료"
        )
    
    async def complete_all(self, download_url: str):
        """전체 작업 완료"""
        self.current_progress = 100
        
        await manager.broadcast(self.ppt_id, {
            "type": "complete",
            "progress": 100,
            "download_url": download_url,
            "message": "🎉 PPT 생성 완료!"
        })
    
    async def report_error(self, error: str):
        """에러 발생 알림"""
        await manager.broadcast(self.ppt_id, {
            "type": "error",
            "progress": self.current_progress,
            "error": error,
            "message": f"⚠️ 오류 발생: {error}"
        })
    
    async def _send_update(
        self, 
        stage: str, 
        status: str, 
        progress: Optional[float] = None,
        message: Optional[str] = None
    ):
        """WebSocket 메시지 전송"""
        await manager.broadcast(self.ppt_id, {
            "type": "progress",
            "stage": stage,
            "status": status,
            "progress": progress or self.current_progress,
            "message": message
        })
```

---

## Task 1.3: WorkflowOrchestrator 통합 (Day 2)

### 파일: `app/services/workflow_orchestrator.py` (수정)

```python
from app.services.progress_tracker import ProgressTracker

class WorkflowOrchestrator:
    
    async def execute_workflow(
        self, 
        input_data: Dict,
        ppt_id: str  # ✨ 신규 파라미터
    ) -> Dict:
        """진행률 추적이 통합된 워크플로우 실행"""
        
        # 진행률 추적기 초기화
        tracker = ProgressTracker(ppt_id)
        context = {"input": input_data}
        
        stages = [
            ("document_analysis", self._analyze_document),
            ("structure_design", self._design_structure),
            ("content_generation", self._generate_content),
            ("design_application", self._apply_design),
            ("quality_review", self._review_quality)
        ]
        
        for stage_name, stage_func in stages:
            # 스테이지 시작
            await tracker.start_stage(stage_name)
            
            try:
                # 스테이지 실행 (progress callback 전달)
                async def progress_callback(p: float):
                    await tracker.update_progress(p)
                
                result = await stage_func(
                    context, 
                    progress_callback=progress_callback
                )
                
                context[stage_name] = result
                
                # 스테이지 완료
                await tracker.complete_stage()
                
            except Exception as e:
                await tracker.report_error(str(e))
                raise
        
        return context
```

### 각 스테이지 함수 수정 예시:

```python
async def _generate_content(
    self, 
    context: Dict,
    progress_callback  # ✨ 신규 파라미터
) -> Dict:
    """콘텐츠 생성 (진행률 보고 포함)"""
    
    outline = context["structure_design"]["outline"]
    total_slides = len(outline["slides"])
    
    slides = []
    for i, slide_spec in enumerate(outline["slides"]):
        # 슬라이드 생성
        slide = await self.content_generator.generate_slide(slide_spec)
        slides.append(slide)
        
        # 진행률 보고
        progress = (i + 1) / total_slides
        await progress_callback(progress)
    
    return {"slides": slides}
```

---

## Task 1.4: 슬라이드 프리뷰 시스템 (Day 3-4)

### 파일: `app/services/preview_generator.py` (신규)

```python
"""
슬라이드 PNG 프리뷰 생성
"""

from pptx import Presentation
from PIL import Image
import io
import os
from typing import List

class PreviewGenerator:
    """슬라이드를 PNG 이미지로 변환"""
    
    def __init__(self, preview_dir: str = "storage/previews"):
        self.preview_dir = preview_dir
        os.makedirs(preview_dir, exist_ok=True)
    
    async def generate_preview(
        self, 
        ppt_path: str, 
        ppt_id: str,
        slide_number: int
    ) -> str:
        """
        특정 슬라이드 프리뷰 생성
        
        Returns:
            str: 프리뷰 이미지 URL
        """
        
        # PPTX → PNG 변환 (python-pptx는 직접 지원 안함)
        # 대안 1: LibreOffice 커맨드라인 사용
        # 대안 2: aspose.slides (유료)
        # 대안 3: 임시 방편으로 슬라이드 썸네일 생성
        
        preview_path = f"{self.preview_dir}/{ppt_id}_slide_{slide_number}.png"
        
        # LibreOffice 변환 (시스템에 설치 필요)
        import subprocess
        
        cmd = [
            "soffice",
            "--headless",
            "--convert-to", "png",
            "--outdir", self.preview_dir,
            ppt_path
        ]
        
        subprocess.run(cmd, check=True)
        
        return f"/preview/{ppt_id}/slide/{slide_number}"
    
    async def generate_all_previews(
        self, 
        ppt_path: str, 
        ppt_id: str
    ) -> List[str]:
        """전체 슬라이드 프리뷰 생성"""
        
        prs = Presentation(ppt_path)
        preview_urls = []
        
        for i in range(len(prs.slides)):
            url = await self.generate_preview(ppt_path, ppt_id, i + 1)
            preview_urls.append(url)
        
        return preview_urls
```

### 파일: `app/api/endpoints.py` (수정)

```python
from fastapi.responses import FileResponse
from app.services.preview_generator import PreviewGenerator

preview_gen = PreviewGenerator()

@app.get("/preview/{ppt_id}/slide/{slide_number}")
async def get_slide_preview(ppt_id: str, slide_number: int):
    """슬라이드 프리뷰 이미지 반환"""
    
    preview_path = f"storage/previews/{ppt_id}_slide_{slide_number}.png"
    
    if not os.path.exists(preview_path):
        raise HTTPException(status_code=404, detail="Preview not found")
    
    return FileResponse(
        preview_path,
        media_type="image/png",
        headers={"Cache-Control": "public, max-age=3600"}
    )
```

### ProgressTracker에 프리뷰 추가 (수정)

```python
async def complete_stage(self):
    """스테이지 완료 (프리뷰 포함)"""
    
    # ... 기존 코드 ...
    
    # 디자인 적용 완료 시 프리뷰 생성
    if self.current_stage == "design_application":
        preview_urls = await self._generate_previews()
        
        await manager.broadcast(self.ppt_id, {
            "type": "preview_ready",
            "preview_urls": preview_urls,
            "message": "🖼️ 미리보기 준비 완료"
        })
```

---

## Task 1.5: 원클릭 스타일 변경 (Day 5)

### 파일: `app/templates/style_presets.py` (신규)

```python
"""
사전 정의된 스타일 프리셋
"""

from dataclasses import dataclass
from typing import Dict

@dataclass
class StylePreset:
    """스타일 프리셋 정의"""
    
    name: str
    colors: Dict[str, str]
    fonts: Dict[str, Dict]
    chart_style: str
    
class StyleLibrary:
    """스타일 프리셋 라이브러리"""
    
    PRESETS = {
        "mckinsey": StylePreset(
            name="McKinsey Classic",
            colors={
                "primary": "#0076A8",
                "secondary": "#F47621",
                "text": "#53565A",
                "background": "#FFFFFF",
                "positive": "#6BA644",
                "negative": "#E31B23"
            },
            fonts={
                "title": {"family": "Arial", "size": 18, "weight": "bold"},
                "body": {"family": "Arial", "size": 14, "weight": "normal"},
                "caption": {"family": "Arial", "size": 10, "weight": "light"}
            },
            chart_style="clean"
        ),
        
        "bcg": StylePreset(
            name="BCG Dynamic",
            colors={
                "primary": "#00A65A",  # BCG Green
                "secondary": "#FF6B35",
                "text": "#2C3E50",
                "background": "#FFFFFF",
                "positive": "#27AE60",
                "negative": "#E74C3C"
            },
            fonts={
                "title": {"family": "Calibri", "size": 20, "weight": "bold"},
                "body": {"family": "Calibri", "size": 14, "weight": "normal"},
                "caption": {"family": "Calibri", "size": 11, "weight": "light"}
            },
            chart_style="gradient"
        ),
        
        "bain": StylePreset(
            name="Bain Conservative",
            colors={
                "primary": "#003B5C",  # Navy
                "secondary": "#8B0000",  # Dark Red
                "text": "#333333",
                "background": "#F5F5F5",
                "positive": "#2E7D32",
                "negative": "#C62828"
            },
            fonts={
                "title": {"family": "Georgia", "size": 18, "weight": "bold"},
                "body": {"family": "Georgia", "size": 13, "weight": "normal"},
                "caption": {"family": "Georgia", "size": 10, "weight": "light"}
            },
            chart_style="classic"
        ),
        
        "minimal": StylePreset(
            name="Minimal Black",
            colors={
                "primary": "#000000",
                "secondary": "#666666",
                "text": "#333333",
                "background": "#FFFFFF",
                "positive": "#000000",
                "negative": "#000000"
            },
            fonts={
                "title": {"family": "Helvetica", "size": 24, "weight": "light"},
                "body": {"family": "Helvetica", "size": 14, "weight": "light"},
                "caption": {"family": "Helvetica", "size": 10, "weight": "light"}
            },
            chart_style="minimal"
        )
    }
    
    @classmethod
    def get_preset(cls, style_name: str) -> StylePreset:
        """스타일 프리셋 조회"""
        return cls.PRESETS.get(style_name, cls.PRESETS["mckinsey"])
```

### 파일: `app/services/style_applicator.py` (신규)

```python
"""
스타일 재적용 시스템 (콘텐츠 유지)
"""

from pptx import Presentation
from pptx.util import Pt, Inches
from pptx.dml.color import RGBColor
from app.templates.style_presets import StyleLibrary

class StyleApplicator:
    """기존 PPT에 새로운 스타일 적용"""
    
    def __init__(self):
        self.style_library = StyleLibrary()
    
    async def reapply_style(
        self, 
        ppt_path: str, 
        new_style: str
    ) -> str:
        """
        기존 PPT 파일에 새 스타일 적용
        
        Returns:
            str: 새 PPT 파일 경로
        """
        
        preset = self.style_library.get_preset(new_style)
        prs = Presentation(ppt_path)
        
        for slide in prs.slides:
            # 1. 텍스트 스타일 변경
            self._apply_text_style(slide, preset)
            
            # 2. 색상 변경
            self._apply_colors(slide, preset)
            
            # 3. 차트 스타일 변경
            self._apply_chart_style(slide, preset)
        
        # 새 파일로 저장
        new_path = ppt_path.replace(".pptx", f"_{new_style}.pptx")
        prs.save(new_path)
        
        return new_path
    
    def _apply_text_style(self, slide, preset: StylePreset):
        """텍스트 폰트 및 크기 변경"""
        
        for shape in slide.shapes:
            if not shape.has_text_frame:
                continue
            
            for paragraph in shape.text_frame.paragraphs:
                for run in paragraph.runs:
                    # 폰트 패밀리
                    run.font.name = preset.fonts["body"]["family"]
                    
                    # 크기는 기존 비율 유지하면서 조정
                    if run.font.size:
                        ratio = run.font.size.pt / 14  # 기본 body 크기
                        new_size = preset.fonts["body"]["size"] * ratio
                        run.font.size = Pt(new_size)
    
    def _apply_colors(self, slide, preset: StylePreset):
        """색상 변경"""
        
        color_map = {
            "#0076A8": preset.colors["primary"],
            "#F47621": preset.colors["secondary"],
            "#53565A": preset.colors["text"]
        }
        
        for shape in slide.shapes:
            # 도형 채우기 색상
            if shape.shape_type == 1:  # AUTO_SHAPE
                old_color = self._get_fill_color(shape)
                if old_color in color_map:
                    new_color = color_map[old_color]
                    self._set_fill_color(shape, new_color)
    
    def _apply_chart_style(self, slide, preset: StylePreset):
        """차트 스타일 변경"""
        
        for shape in slide.shapes:
            if shape.has_chart:
                chart = shape.chart
                
                # 차트 색상 팔레트 변경
                if preset.chart_style == "gradient":
                    # BCG 스타일: 그라데이션
                    pass
                elif preset.chart_style == "minimal":
                    # Minimal: 흑백 음영
                    pass
```

### API 엔드포인트

```python
@app.post("/regenerate-style")
async def regenerate_with_style(
    ppt_id: str,
    new_style: str  # "mckinsey" | "bcg" | "bain" | "minimal"
):
    """
    스타일만 변경 (3초 이내 완료)
    
    프로세스:
    1. 기존 PPT 로드
    2. 스타일 재적용 (LLM 호출 없음!)
    3. 새 파일 저장
    4. 다운로드 URL 반환
    """
    
    # 기존 파일 경로 조회
    original_path = await db.get_ppt_path(ppt_id)
    
    # 스타일 재적용
    applicator = StyleApplicator()
    new_path = await applicator.reapply_style(original_path, new_style)
    
    # 새 PPT ID 생성
    new_ppt_id = generate_unique_id()
    
    # DB 저장
    await db.save_ppt_info(new_ppt_id, {
        "path": new_path,
        "style": new_style,
        "parent_id": ppt_id
    })
    
    return {
        "new_ppt_id": new_ppt_id,
        "download_url": f"/download/{new_ppt_id}",
        "processing_time": "2.7초"  # 실제 측정값
    }
```

---

# 📋 Week 2: 발표 준비 지원

## Task 2.1: AI 발표자 노트 생성기 (Day 1-2)

### 파일: `app/services/speaker_notes_generator.py` (신규)

```python
"""
AI 기반 발표자 노트 자동 생성
"""

from typing import Dict, List
import json

class SpeakerNotesGenerator:
    """슬라이드별 발표 스크립트 생성"""
    
    def __init__(self):
        self.llm_client = LLMClient(model="gpt-4-turbo")
    
    async def generate_notes(
        self, 
        slide_spec: Dict,
        slide_number: int,
        total_slides: int,
        context: Dict  # 전체 프레젠테이션 맥락
    ) -> Dict:
        """
        발표자 노트 생성
        
        Returns:
            {
                "opening": "도입 멘트 (5초)",
                "key_points": ["포인트 1", "포인트 2", "포인트 3"],
                "transition": "다음 슬라이드 전환 멘트",
                "timing": 45,  # 권장 발표 시간 (초)
                "emphasis": ["강조할 숫자", "강조할 키워드"]
            }
        """
        
        prompt = self._build_prompt(
            slide_spec, 
            slide_number, 
            total_slides, 
            context
        )
        
        response = await self.llm_client.generate(prompt)
        notes = json.loads(response)
        
        return notes
    
    def _build_prompt(
        self, 
        slide_spec: Dict, 
        slide_number: int,
        total_slides: int,
        context: Dict
    ) -> str:
        """프롬프트 생성"""
        
        # 이전/다음 슬라이드 제목 (맥락 제공)
        prev_title = context.get("prev_slide_title", "")
        next_title = context.get("next_slide_title", "")
        
        return f"""
당신은 McKinsey 시니어 파트너입니다.
다음 슬라이드에 대한 발표 스크립트를 작성하세요.

## 슬라이드 정보
- 번호: {slide_number} / {total_slides}
- 제목: {slide_spec['headline']}
- 콘텐츠: {slide_spec['content']}
- 차트: {slide_spec.get('chart_type', 'None')}

## 맥락
- 이전 슬라이드: {prev_title}
- 다음 슬라이드: {next_title}

## 작성 지침
1. **도입 멘트** (5-10초)
   - 이전 슬라이드와 자연스럽게 연결
   - 청중의 관심 끌기

2. **핵심 포인트** (30-40초)
   - 3가지 핵심 메시지
   - 데이터 수치 구체적으로 언급
   - "So What?" 명확히 전달

3. **전환 멘트** (5초)
   - 다음 슬라이드 예고
   - 청중의 기대감 유발

4. **강조 포인트**
   - 특히 강조해야 할 숫자/키워드
   - 음성 톤 조절 지점

5. **타이밍**
   - 권장 발표 시간 (초 단위)
   - 너무 빠르거나 느리지 않게

## 출력 형식 (JSON만)
{{
    "opening": "이전 슬라이드에서 문제를 확인했습니다. 이제 해결책을 보시겠습니다.",
    "key_points": [
        "첫 번째로, 시장 점유율이 25%에서 40%로 증가했습니다",
        "두 번째로, 이는 신제품 라인이 70% 기여했기 때문입니다",
        "세 번째로, 이 추세는 향후 2년간 지속될 것으로 예상됩니다"
    ],
    "transition": "이러한 성장을 지속하기 위한 3가지 전략을 다음 슬라이드에서 제시하겠습니다",
    "timing": 45,
    "emphasis": ["40%", "70%", "2년"]
}}
"""
    
    async def generate_all_notes(
        self, 
        slides: List[Dict]
    ) -> List[Dict]:
        """전체 슬라이드 발표자 노트 생성"""
        
        all_notes = []
        total_slides = len(slides)
        
        for i, slide in enumerate(slides):
            # 맥락 정보 구성
            context = {
                "prev_slide_title": slides[i-1]["headline"] if i > 0 else "",
                "next_slide_title": slides[i+1]["headline"] if i < total_slides-1 else ""
            }
            
            notes = await self.generate_notes(
                slide, 
                i + 1, 
                total_slides,
                context
            )
            
            all_notes.append(notes)
        
        return all_notes
```

---

## Task 2.2: 예상 질문 + 답변 생성 (Day 3-4)

### 파일: `app/services/qa_generator.py` (신규)

```python
"""
예상 질문 및 답변 생성
"""

from typing import Dict, List

class QAGenerator:
    """질의응답 생성기"""
    
    def __init__(self):
        self.llm_client = LLMClient(model="gpt-4-turbo")
    
    async def generate_qa(
        self, 
        slide_spec: Dict,
        full_presentation: Dict
    ) -> List[Dict]:
        """
        슬라이드별 예상 질문 3개 + 답변 생성
        
        Returns:
            [
                {
                    "question": "이 수치는 어떻게 산출했나요?",
                    "answer": "2023-2024 재무제표 기반 연평균 성장률입니다",
                    "reference_slide": 5,  # 참조 슬라이드 번호
                    "difficulty": "medium"  # easy/medium/hard
                },
                ...
            ]
        """
        
        prompt = f"""
당신은 경영진 프레젠테이션 경험이 풍부한 McKinsey 파트너입니다.
다음 슬라이드에 대해 청중이 물어볼 가능성이 높은 질문 3개를 예측하고 답변을 준비하세요.

## 슬라이드 정보
- 제목: {slide_spec['headline']}
- 콘텐츠: {slide_spec['content']}
- 데이터: {slide_spec.get('data', {})}

## 전체 프레젠테이션 맥락
- 주제: {full_presentation['title']}
- 목적: {full_presentation['objective']}
- 타겟 청중: {full_presentation['audience']}

## 질문 유형 (난이도 순)
1. **Easy**: 사실 확인, 정의 질문
   - "이 수치의 출처는?"
   - "타임라인은 어떻게 되나요?"

2. **Medium**: 방법론, 비교 질문
   - "경쟁사와 비교하면?"
   - "이 가정의 근거는?"

3. **Hard**: 전략적 의사결정, 대안 시나리오
   - "Plan B는 무엇인가요?"
   - "리스크는 어떻게 관리하나요?"

## 답변 작성 지침
- 간결하고 명확하게 (30초 이내)
- 가능한 프레젠테이션 내 다른 슬라이드 참조
- 모르면 "추가 분석 후 답변드리겠습니다" (정직)
- 수치는 구체적으로

## 출력 형식 (JSON만)
[
    {{
        "question": "이 40% 성장률은 어떻게 산출했나요?",
        "answer": "2023년 매출 1,000억원에서 2024년 1,400억원으로 증가한 실적 기반입니다. 세부 내역은 슬라이드 7번 재무 분석을 참고해주세요.",
        "reference_slide": 7,
        "difficulty": "medium"
    }},
    ...
]
"""
        
        response = await self.llm_client.generate(prompt)
        qa_list = json.loads(response)
        
        return qa_list
    
    async def generate_executive_qa(
        self, 
        full_presentation: Dict
    ) -> List[Dict]:
        """
        전체 프레젠테이션에 대한 고난도 질문 (CEO/CFO급)
        
        예시:
        - "3년 후 시장 환경이 악화되면?"
        - "투자 ROI 계산 근거는?"
        - "조직 역량은 충분한가?"
        """
        
        prompt = f"""
CEO/CFO급 경영진이 물어볼 전략적 질문 5개를 예측하세요.

## 프레젠테이션 요약
{json.dumps(full_presentation, ensure_ascii=False, indent=2)}

## 질문 유형
1. **재무적 타당성**
   - ROI, NPV, Payback Period
   - 비용 구조, 수익 모델

2. **전략적 리스크**
   - 시장 변화 시나리오
   - 경쟁 대응 전략

3. **실행 가능성**
   - 조직 역량
   - 리소스 충분성
   - 타임라인 현실성

4. **대안 및 최적화**
   - Plan B
   - 우선순위 조정
   - 단계적 접근

출력: JSON 리스트
"""
        
        response = await self.llm_client.generate(prompt)
        return json.loads(response)
```

---

## Task 2.3: PPT 파일에 스피커 노트 삽입 (Day 5)

### 파일: `app/services/notes_inserter.py` (신규)

```python
"""
생성된 발표자 노트를 PPT 파일에 삽입
"""

from pptx import Presentation
from typing import List, Dict

class NotesInserter:
    """PPT 파일에 노트 삽입"""
    
    async def insert_notes(
        self, 
        ppt_path: str,
        speaker_notes: List[Dict],
        qa_pairs: List[List[Dict]]  # 슬라이드별 Q&A 리스트
    ) -> str:
        """
        PPT 파일에 발표자 노트 삽입
        
        Args:
            ppt_path: PPT 파일 경로
            speaker_notes: 슬라이드별 발표자 노트
            qa_pairs: 슬라이드별 예상 Q&A
        
        Returns:
            str: 노트가 삽입된 새 PPT 파일 경로
        """
        
        prs = Presentation(ppt_path)
        
        for i, slide in enumerate(prs.slides):
            if i >= len(speaker_notes):
                break
            
            # 노트 텍스트 구성
            notes_text = self._format_notes(
                speaker_notes[i],
                qa_pairs[i] if i < len(qa_pairs) else []
            )
            
            # PPT 노트에 삽입
            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes_text
        
        # 새 파일로 저장
        new_path = ppt_path.replace(".pptx", "_with_notes.pptx")
        prs.save(new_path)
        
        return new_path
    
    def _format_notes(
        self, 
        speaker_notes: Dict,
        qa_list: List[Dict]
    ) -> str:
        """노트 텍스트 포맷팅"""
        
        text = f"""
🎤 발표 스크립트 (권장 시간: {speaker_notes['timing']}초)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

▶ 도입 (5-10초)
{speaker_notes['opening']}

▶ 핵심 포인트 (30-40초)
"""
        
        for i, point in enumerate(speaker_notes['key_points'], 1):
            text += f"\n{i}. {point}"
        
        text += f"\n\n▶ 전환 멘트 (5초)\n{speaker_notes['transition']}"
        
        if speaker_notes['emphasis']:
            text += f"\n\n🔴 강조할 포인트:\n"
            for item in speaker_notes['emphasis']:
                text += f"  • {item}\n"
        
        if qa_list:
            text += "\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
            text += "❓ 예상 질문 & 답변\n\n"
            
            for j, qa in enumerate(qa_list, 1):
                text += f"{j}. Q: {qa['question']}\n"
                text += f"   A: {qa['answer']}\n"
                
                if qa.get('reference_slide'):
                    text += f"   → 참조: 슬라이드 {qa['reference_slide']}번\n"
                
                text += "\n"
        
        return text
```

### WorkflowOrchestrator 통합

```python
async def execute_workflow(self, input_data: Dict, ppt_id: str) -> Dict:
    """워크플로우에 발표자 노트 생성 추가"""
    
    # ... 기존 파이프라인 ...
    
    # 발표자 노트 생성 (선택적)
    if input_data.get("generate_speaker_notes", True):
        notes_gen = SpeakerNotesGenerator()
        qa_gen = QAGenerator()
        
        speaker_notes = await notes_gen.generate_all_notes(
            context["content_generation"]["slides"]
        )
        
        qa_pairs = []
        for slide in context["content_generation"]["slides"]:
            qa = await qa_gen.generate_qa(slide, input_data)
            qa_pairs.append(qa)
        
        # PPT에 삽입
        inserter = NotesInserter()
        final_ppt_path = await inserter.insert_notes(
            context["ppt_path"],
            speaker_notes,
            qa_pairs
        )
        
        context["final_ppt_path"] = final_ppt_path
        context["speaker_notes"] = speaker_notes
        context["qa_pairs"] = qa_pairs
    
    return context
```

---

