# ğŸ¯ ì‚¬ìš©ì í¸ì˜ì„± ê°•í™” - ì „ì²´ êµ¬í˜„ ê³„íšì„œ

ì™„ë²½í•©ë‹ˆë‹¤! 4ì£¼ ê³„íšì„ ìƒì„¸ ì‘ì—…ì§€ì‹œì„œë¡œ ë§Œë“¤ì–´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

---

## ğŸ“… ì „ì²´ íƒ€ì„ë¼ì¸ (4ì£¼)

```
Week 1: ì¦‰ì‹œ ì²´ê° ê°œì„  (ì‹¤ì‹œê°„ í”¼ë“œë°±)
â”œâ”€â”€ Day 1-2: WebSocket ì¸í”„ë¼ + ì§„í–‰ë¥  í‘œì‹œ
â”œâ”€â”€ Day 3-4: ìŠ¬ë¼ì´ë“œ í”„ë¦¬ë·° ì‹œìŠ¤í…œ
â””â”€â”€ Day 5: ì›í´ë¦­ ìŠ¤íƒ€ì¼ ë³€ê²½

Week 2: ë°œí‘œ ì¤€ë¹„ ì§€ì›
â”œâ”€â”€ Day 1-2: AI ë°œí‘œì ë…¸íŠ¸ ìƒì„±
â”œâ”€â”€ Day 3-4: ì˜ˆìƒ ì§ˆë¬¸ + ë‹µë³€ ìƒì„±
â””â”€â”€ Day 5: ìŠ¤í”¼ì»¤ ë…¸íŠ¸ PPT ì‚½ì…

Week 3: ìŠ¤ë§ˆíŠ¸ í¸ì§‘ ê¸°ëŠ¥
â”œâ”€â”€ Day 1-2: ìŠ¬ë¼ì´ë“œ ì¶”ê°€/ì‚­ì œ/ì¬ë°°ì—´
â”œâ”€â”€ Day 3-4: ìì—°ì–´ í¸ì§‘ ëª…ë ¹ íŒŒì„œ
â””â”€â”€ Day 5: í¸ì§‘ ëª…ë ¹ ì‹¤í–‰ ì—”ì§„

Week 4: ë²„ì „ ê´€ë¦¬ + í†µí•©
â”œâ”€â”€ Day 1-2: ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ
â”œâ”€â”€ Day 3: ë²„ì „ ë¹„êµ ë·°
â”œâ”€â”€ Day 4: í†µí•© í…ŒìŠ¤íŠ¸
â””â”€â”€ Day 5: ë¬¸ì„œí™” + ë°°í¬
```

---

# ğŸ“‹ Week 1: ì¦‰ì‹œ ì²´ê° ê°œì„ 

## Task 1.1: WebSocket ì¸í”„ë¼ êµ¬ì¶• (Day 1)

### íŒŒì¼: `app/core/websocket_manager.py` (ì‹ ê·œ)

```python
"""
WebSocket ì—°ê²° ê´€ë¦¬ ë° ì‹¤ì‹œê°„ ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŒ…
"""

from fastapi import WebSocket
from typing import Dict, List
import asyncio
import json

class ConnectionManager:
    """WebSocket ì—°ê²° ê´€ë¦¬ì"""
    
    def __init__(self):
        # ppt_idë³„ í™œì„± ì—°ê²° ê´€ë¦¬
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, ppt_id: str):
        """í´ë¼ì´ì–¸íŠ¸ ì—°ê²°"""
        await websocket.accept()
        
        if ppt_id not in self.active_connections:
            self.active_connections[ppt_id] = []
        
        self.active_connections[ppt_id].append(websocket)
    
    def disconnect(self, websocket: WebSocket, ppt_id: str):
        """í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ"""
        if ppt_id in self.active_connections:
            self.active_connections[ppt_id].remove(websocket)
            
            # ì—°ê²°ì´ ì—†ìœ¼ë©´ í‚¤ ì‚­ì œ
            if not self.active_connections[ppt_id]:
                del self.active_connections[ppt_id]
    
    async def broadcast(self, ppt_id: str, message: Dict):
        """íŠ¹ì • PPT ì‘ì—…ì˜ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì— ë©”ì‹œì§€ ì „ì†¡"""
        if ppt_id not in self.active_connections:
            return
        
        dead_connections = []
        
        for connection in self.active_connections[ppt_id]:
            try:
                await connection.send_json(message)
            except Exception:
                dead_connections.append(connection)
        
        # ëŠê¸´ ì—°ê²° ì œê±°
        for dead in dead_connections:
            self.disconnect(dead, ppt_id)

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
manager = ConnectionManager()
```

### íŒŒì¼: `app/api/websocket.py` (ì‹ ê·œ)

```python
"""
WebSocket ì—”ë“œí¬ì¸íŠ¸
"""

from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from app.core.websocket_manager import manager

router = APIRouter()

@router.websocket("/ws/progress/{ppt_id}")
async def websocket_endpoint(websocket: WebSocket, ppt_id: str):
    """
    ì‹¤ì‹œê°„ ì§„í–‰ ìƒí™© ìŠ¤íŠ¸ë¦¬ë°
    
    í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©ë²•:
    const ws = new WebSocket('ws://localhost:8000/ws/progress/abc123');
    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        console.log(data.stage, data.progress);
    };
    """
    
    await manager.connect(websocket, ppt_id)
    
    try:
        # ì—°ê²° ìœ ì§€ (ë©”ì‹œì§€ëŠ” ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì—ì„œ ì „ì†¡)
        while True:
            # í´ë¼ì´ì–¸íŠ¸ í•‘ ëŒ€ê¸°
            await websocket.receive_text()
            
    except WebSocketDisconnect:
        manager.disconnect(websocket, ppt_id)
```

### íŒŒì¼: `app/api/router.py` (ìˆ˜ì •)

```python
# WebSocket ë¼ìš°í„° ì¶”ê°€
from app.api import websocket

app.include_router(websocket.router, tags=["websocket"])
```

---

## Task 1.2: ì§„í–‰ë¥  ì¶”ì  ì‹œìŠ¤í…œ (Day 2)

### íŒŒì¼: `app/services/progress_tracker.py` (ì‹ ê·œ)

```python
"""
ì‘ì—… ì§„í–‰ë¥  ì¶”ì  ë° WebSocket ì•Œë¦¼
"""

from app.core.websocket_manager import manager
from typing import Dict, Optional
import asyncio

class ProgressTracker:
    """ì§„í–‰ë¥  ì¶”ì  ë° ì•Œë¦¼"""
    
    # ê° ìŠ¤í…Œì´ì§€ë³„ ê°€ì¤‘ì¹˜ (ì´ 100%)
    STAGE_WEIGHTS = {
        "document_analysis": 15,
        "structure_design": 20,
        "content_generation": 30,
        "design_application": 25,
        "quality_review": 10
    }
    
    STAGE_NAMES_KR = {
        "document_analysis": "ğŸ“„ ë¬¸ì„œ ë¶„ì„ ì¤‘",
        "structure_design": "ğŸ—ï¸ êµ¬ì¡° ì„¤ê³„ ì¤‘",
        "content_generation": "âœï¸ ì½˜í…ì¸  ìƒì„± ì¤‘",
        "design_application": "ğŸ¨ ë””ìì¸ ì ìš© ì¤‘",
        "quality_review": "âœ… í’ˆì§ˆ ê²€ì¦ ì¤‘"
    }
    
    def __init__(self, ppt_id: str):
        self.ppt_id = ppt_id
        self.current_progress = 0
        self.current_stage = None
        self.stage_start_progress = 0
    
    async def start_stage(self, stage: str):
        """ìŠ¤í…Œì´ì§€ ì‹œì‘ ì•Œë¦¼"""
        self.current_stage = stage
        self.stage_start_progress = self.current_progress
        
        await self._send_update(
            stage=self.STAGE_NAMES_KR[stage],
            status="started",
            message=f"{self.STAGE_NAMES_KR[stage]} ì‹œì‘"
        )
    
    async def update_progress(self, stage_progress: float):
        """
        ìŠ¤í…Œì´ì§€ ë‚´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        
        Args:
            stage_progress: 0.0 ~ 1.0 (í˜„ì¬ ìŠ¤í…Œì´ì§€ ì§„í–‰ë¥ )
        """
        if not self.current_stage:
            return
        
        stage_weight = self.STAGE_WEIGHTS[self.current_stage]
        added_progress = stage_weight * stage_progress
        
        self.current_progress = self.stage_start_progress + added_progress
        
        await self._send_update(
            stage=self.STAGE_NAMES_KR[self.current_stage],
            status="in_progress",
            progress=round(self.current_progress, 1)
        )
    
    async def complete_stage(self):
        """ìŠ¤í…Œì´ì§€ ì™„ë£Œ"""
        if not self.current_stage:
            return
        
        stage_weight = self.STAGE_WEIGHTS[self.current_stage]
        self.current_progress = self.stage_start_progress + stage_weight
        
        await self._send_update(
            stage=self.STAGE_NAMES_KR[self.current_stage],
            status="completed",
            progress=round(self.current_progress, 1),
            message=f"{self.STAGE_NAMES_KR[self.current_stage]} ì™„ë£Œ"
        )
    
    async def complete_all(self, download_url: str):
        """ì „ì²´ ì‘ì—… ì™„ë£Œ"""
        self.current_progress = 100
        
        await manager.broadcast(self.ppt_id, {
            "type": "complete",
            "progress": 100,
            "download_url": download_url,
            "message": "ğŸ‰ PPT ìƒì„± ì™„ë£Œ!"
        })
    
    async def report_error(self, error: str):
        """ì—ëŸ¬ ë°œìƒ ì•Œë¦¼"""
        await manager.broadcast(self.ppt_id, {
            "type": "error",
            "progress": self.current_progress,
            "error": error,
            "message": f"âš ï¸ ì˜¤ë¥˜ ë°œìƒ: {error}"
        })
    
    async def _send_update(
        self, 
        stage: str, 
        status: str, 
        progress: Optional[float] = None,
        message: Optional[str] = None
    ):
        """WebSocket ë©”ì‹œì§€ ì „ì†¡"""
        await manager.broadcast(self.ppt_id, {
            "type": "progress",
            "stage": stage,
            "status": status,
            "progress": progress or self.current_progress,
            "message": message
        })
```

---

## Task 1.3: WorkflowOrchestrator í†µí•© (Day 2)

### íŒŒì¼: `app/services/workflow_orchestrator.py` (ìˆ˜ì •)

```python
from app.services.progress_tracker import ProgressTracker

class WorkflowOrchestrator:
    
    async def execute_workflow(
        self, 
        input_data: Dict,
        ppt_id: str  # âœ¨ ì‹ ê·œ íŒŒë¼ë¯¸í„°
    ) -> Dict:
        """ì§„í–‰ë¥  ì¶”ì ì´ í†µí•©ëœ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰"""
        
        # ì§„í–‰ë¥  ì¶”ì ê¸° ì´ˆê¸°í™”
        tracker = ProgressTracker(ppt_id)
        context = {"input": input_data}
        
        stages = [
            ("document_analysis", self._analyze_document),
            ("structure_design", self._design_structure),
            ("content_generation", self._generate_content),
            ("design_application", self._apply_design),
            ("quality_review", self._review_quality)
        ]
        
        for stage_name, stage_func in stages:
            # ìŠ¤í…Œì´ì§€ ì‹œì‘
            await tracker.start_stage(stage_name)
            
            try:
                # ìŠ¤í…Œì´ì§€ ì‹¤í–‰ (progress callback ì „ë‹¬)
                async def progress_callback(p: float):
                    await tracker.update_progress(p)
                
                result = await stage_func(
                    context, 
                    progress_callback=progress_callback
                )
                
                context[stage_name] = result
                
                # ìŠ¤í…Œì´ì§€ ì™„ë£Œ
                await tracker.complete_stage()
                
            except Exception as e:
                await tracker.report_error(str(e))
                raise
        
        return context
```

### ê° ìŠ¤í…Œì´ì§€ í•¨ìˆ˜ ìˆ˜ì • ì˜ˆì‹œ:

```python
async def _generate_content(
    self, 
    context: Dict,
    progress_callback  # âœ¨ ì‹ ê·œ íŒŒë¼ë¯¸í„°
) -> Dict:
    """ì½˜í…ì¸  ìƒì„± (ì§„í–‰ë¥  ë³´ê³  í¬í•¨)"""
    
    outline = context["structure_design"]["outline"]
    total_slides = len(outline["slides"])
    
    slides = []
    for i, slide_spec in enumerate(outline["slides"]):
        # ìŠ¬ë¼ì´ë“œ ìƒì„±
        slide = await self.content_generator.generate_slide(slide_spec)
        slides.append(slide)
        
        # ì§„í–‰ë¥  ë³´ê³ 
        progress = (i + 1) / total_slides
        await progress_callback(progress)
    
    return {"slides": slides}
```

---

## Task 1.4: ìŠ¬ë¼ì´ë“œ í”„ë¦¬ë·° ì‹œìŠ¤í…œ (Day 3-4)

### íŒŒì¼: `app/services/preview_generator.py` (ì‹ ê·œ)

```python
"""
ìŠ¬ë¼ì´ë“œ PNG í”„ë¦¬ë·° ìƒì„±
"""

from pptx import Presentation
from PIL import Image
import io
import os
from typing import List

class PreviewGenerator:
    """ìŠ¬ë¼ì´ë“œë¥¼ PNG ì´ë¯¸ì§€ë¡œ ë³€í™˜"""
    
    def __init__(self, preview_dir: str = "storage/previews"):
        self.preview_dir = preview_dir
        os.makedirs(preview_dir, exist_ok=True)
    
    async def generate_preview(
        self, 
        ppt_path: str, 
        ppt_id: str,
        slide_number: int
    ) -> str:
        """
        íŠ¹ì • ìŠ¬ë¼ì´ë“œ í”„ë¦¬ë·° ìƒì„±
        
        Returns:
            str: í”„ë¦¬ë·° ì´ë¯¸ì§€ URL
        """
        
        # PPTX â†’ PNG ë³€í™˜ (python-pptxëŠ” ì§ì ‘ ì§€ì› ì•ˆí•¨)
        # ëŒ€ì•ˆ 1: LibreOffice ì»¤ë§¨ë“œë¼ì¸ ì‚¬ìš©
        # ëŒ€ì•ˆ 2: aspose.slides (ìœ ë£Œ)
        # ëŒ€ì•ˆ 3: ì„ì‹œ ë°©í¸ìœ¼ë¡œ ìŠ¬ë¼ì´ë“œ ì¸ë„¤ì¼ ìƒì„±
        
        preview_path = f"{self.preview_dir}/{ppt_id}_slide_{slide_number}.png"
        
        # LibreOffice ë³€í™˜ (ì‹œìŠ¤í…œì— ì„¤ì¹˜ í•„ìš”)
        import subprocess
        
        cmd = [
            "soffice",
            "--headless",
            "--convert-to", "png",
            "--outdir", self.preview_dir,
            ppt_path
        ]
        
        subprocess.run(cmd, check=True)
        
        return f"/preview/{ppt_id}/slide/{slide_number}"
    
    async def generate_all_previews(
        self, 
        ppt_path: str, 
        ppt_id: str
    ) -> List[str]:
        """ì „ì²´ ìŠ¬ë¼ì´ë“œ í”„ë¦¬ë·° ìƒì„±"""
        
        prs = Presentation(ppt_path)
        preview_urls = []
        
        for i in range(len(prs.slides)):
            url = await self.generate_preview(ppt_path, ppt_id, i + 1)
            preview_urls.append(url)
        
        return preview_urls
```

### íŒŒì¼: `app/api/endpoints.py` (ìˆ˜ì •)

```python
from fastapi.responses import FileResponse
from app.services.preview_generator import PreviewGenerator

preview_gen = PreviewGenerator()

@app.get("/preview/{ppt_id}/slide/{slide_number}")
async def get_slide_preview(ppt_id: str, slide_number: int):
    """ìŠ¬ë¼ì´ë“œ í”„ë¦¬ë·° ì´ë¯¸ì§€ ë°˜í™˜"""
    
    preview_path = f"storage/previews/{ppt_id}_slide_{slide_number}.png"
    
    if not os.path.exists(preview_path):
        raise HTTPException(status_code=404, detail="Preview not found")
    
    return FileResponse(
        preview_path,
        media_type="image/png",
        headers={"Cache-Control": "public, max-age=3600"}
    )
```

### ProgressTrackerì— í”„ë¦¬ë·° ì¶”ê°€ (ìˆ˜ì •)

```python
async def complete_stage(self):
    """ìŠ¤í…Œì´ì§€ ì™„ë£Œ (í”„ë¦¬ë·° í¬í•¨)"""
    
    # ... ê¸°ì¡´ ì½”ë“œ ...
    
    # ë””ìì¸ ì ìš© ì™„ë£Œ ì‹œ í”„ë¦¬ë·° ìƒì„±
    if self.current_stage == "design_application":
        preview_urls = await self._generate_previews()
        
        await manager.broadcast(self.ppt_id, {
            "type": "preview_ready",
            "preview_urls": preview_urls,
            "message": "ğŸ–¼ï¸ ë¯¸ë¦¬ë³´ê¸° ì¤€ë¹„ ì™„ë£Œ"
        })
```

---

## Task 1.5: ì›í´ë¦­ ìŠ¤íƒ€ì¼ ë³€ê²½ (Day 5)

### íŒŒì¼: `app/templates/style_presets.py` (ì‹ ê·œ)

```python
"""
ì‚¬ì „ ì •ì˜ëœ ìŠ¤íƒ€ì¼ í”„ë¦¬ì…‹
"""

from dataclasses import dataclass
from typing import Dict

@dataclass
class StylePreset:
    """ìŠ¤íƒ€ì¼ í”„ë¦¬ì…‹ ì •ì˜"""
    
    name: str
    colors: Dict[str, str]
    fonts: Dict[str, Dict]
    chart_style: str
    
class StyleLibrary:
    """ìŠ¤íƒ€ì¼ í”„ë¦¬ì…‹ ë¼ì´ë¸ŒëŸ¬ë¦¬"""
    
    PRESETS = {
        "mckinsey": StylePreset(
            name="McKinsey Classic",
            colors={
                "primary": "#0076A8",
                "secondary": "#F47621",
                "text": "#53565A",
                "background": "#FFFFFF",
                "positive": "#6BA644",
                "negative": "#E31B23"
            },
            fonts={
                "title": {"family": "Arial", "size": 18, "weight": "bold"},
                "body": {"family": "Arial", "size": 14, "weight": "normal"},
                "caption": {"family": "Arial", "size": 10, "weight": "light"}
            },
            chart_style="clean"
        ),
        
        "bcg": StylePreset(
            name="BCG Dynamic",
            colors={
                "primary": "#00A65A",  # BCG Green
                "secondary": "#FF6B35",
                "text": "#2C3E50",
                "background": "#FFFFFF",
                "positive": "#27AE60",
                "negative": "#E74C3C"
            },
            fonts={
                "title": {"family": "Calibri", "size": 20, "weight": "bold"},
                "body": {"family": "Calibri", "size": 14, "weight": "normal"},
                "caption": {"family": "Calibri", "size": 11, "weight": "light"}
            },
            chart_style="gradient"
        ),
        
        "bain": StylePreset(
            name="Bain Conservative",
            colors={
                "primary": "#003B5C",  # Navy
                "secondary": "#8B0000",  # Dark Red
                "text": "#333333",
                "background": "#F5F5F5",
                "positive": "#2E7D32",
                "negative": "#C62828"
            },
            fonts={
                "title": {"family": "Georgia", "size": 18, "weight": "bold"},
                "body": {"family": "Georgia", "size": 13, "weight": "normal"},
                "caption": {"family": "Georgia", "size": 10, "weight": "light"}
            },
            chart_style="classic"
        ),
        
        "minimal": StylePreset(
            name="Minimal Black",
            colors={
                "primary": "#000000",
                "secondary": "#666666",
                "text": "#333333",
                "background": "#FFFFFF",
                "positive": "#000000",
                "negative": "#000000"
            },
            fonts={
                "title": {"family": "Helvetica", "size": 24, "weight": "light"},
                "body": {"family": "Helvetica", "size": 14, "weight": "light"},
                "caption": {"family": "Helvetica", "size": 10, "weight": "light"}
            },
            chart_style="minimal"
        )
    }
    
    @classmethod
    def get_preset(cls, style_name: str) -> StylePreset:
        """ìŠ¤íƒ€ì¼ í”„ë¦¬ì…‹ ì¡°íšŒ"""
        return cls.PRESETS.get(style_name, cls.PRESETS["mckinsey"])
```

### íŒŒì¼: `app/services/style_applicator.py` (ì‹ ê·œ)

```python
"""
ìŠ¤íƒ€ì¼ ì¬ì ìš© ì‹œìŠ¤í…œ (ì½˜í…ì¸  ìœ ì§€)
"""

from pptx import Presentation
from pptx.util import Pt, Inches
from pptx.dml.color import RGBColor
from app.templates.style_presets import StyleLibrary

class StyleApplicator:
    """ê¸°ì¡´ PPTì— ìƒˆë¡œìš´ ìŠ¤íƒ€ì¼ ì ìš©"""
    
    def __init__(self):
        self.style_library = StyleLibrary()
    
    async def reapply_style(
        self, 
        ppt_path: str, 
        new_style: str
    ) -> str:
        """
        ê¸°ì¡´ PPT íŒŒì¼ì— ìƒˆ ìŠ¤íƒ€ì¼ ì ìš©
        
        Returns:
            str: ìƒˆ PPT íŒŒì¼ ê²½ë¡œ
        """
        
        preset = self.style_library.get_preset(new_style)
        prs = Presentation(ppt_path)
        
        for slide in prs.slides:
            # 1. í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ ë³€ê²½
            self._apply_text_style(slide, preset)
            
            # 2. ìƒ‰ìƒ ë³€ê²½
            self._apply_colors(slide, preset)
            
            # 3. ì°¨íŠ¸ ìŠ¤íƒ€ì¼ ë³€ê²½
            self._apply_chart_style(slide, preset)
        
        # ìƒˆ íŒŒì¼ë¡œ ì €ì¥
        new_path = ppt_path.replace(".pptx", f"_{new_style}.pptx")
        prs.save(new_path)
        
        return new_path
    
    def _apply_text_style(self, slide, preset: StylePreset):
        """í…ìŠ¤íŠ¸ í°íŠ¸ ë° í¬ê¸° ë³€ê²½"""
        
        for shape in slide.shapes:
            if not shape.has_text_frame:
                continue
            
            for paragraph in shape.text_frame.paragraphs:
                for run in paragraph.runs:
                    # í°íŠ¸ íŒ¨ë°€ë¦¬
                    run.font.name = preset.fonts["body"]["family"]
                    
                    # í¬ê¸°ëŠ” ê¸°ì¡´ ë¹„ìœ¨ ìœ ì§€í•˜ë©´ì„œ ì¡°ì •
                    if run.font.size:
                        ratio = run.font.size.pt / 14  # ê¸°ë³¸ body í¬ê¸°
                        new_size = preset.fonts["body"]["size"] * ratio
                        run.font.size = Pt(new_size)
    
    def _apply_colors(self, slide, preset: StylePreset):
        """ìƒ‰ìƒ ë³€ê²½"""
        
        color_map = {
            "#0076A8": preset.colors["primary"],
            "#F47621": preset.colors["secondary"],
            "#53565A": preset.colors["text"]
        }
        
        for shape in slide.shapes:
            # ë„í˜• ì±„ìš°ê¸° ìƒ‰ìƒ
            if shape.shape_type == 1:  # AUTO_SHAPE
                old_color = self._get_fill_color(shape)
                if old_color in color_map:
                    new_color = color_map[old_color]
                    self._set_fill_color(shape, new_color)
    
    def _apply_chart_style(self, slide, preset: StylePreset):
        """ì°¨íŠ¸ ìŠ¤íƒ€ì¼ ë³€ê²½"""
        
        for shape in slide.shapes:
            if shape.has_chart:
                chart = shape.chart
                
                # ì°¨íŠ¸ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ë³€ê²½
                if preset.chart_style == "gradient":
                    # BCG ìŠ¤íƒ€ì¼: ê·¸ë¼ë°ì´ì…˜
                    pass
                elif preset.chart_style == "minimal":
                    # Minimal: í‘ë°± ìŒì˜
                    pass
```

### API ì—”ë“œí¬ì¸íŠ¸

```python
@app.post("/regenerate-style")
async def regenerate_with_style(
    ppt_id: str,
    new_style: str  # "mckinsey" | "bcg" | "bain" | "minimal"
):
    """
    ìŠ¤íƒ€ì¼ë§Œ ë³€ê²½ (3ì´ˆ ì´ë‚´ ì™„ë£Œ)
    
    í”„ë¡œì„¸ìŠ¤:
    1. ê¸°ì¡´ PPT ë¡œë“œ
    2. ìŠ¤íƒ€ì¼ ì¬ì ìš© (LLM í˜¸ì¶œ ì—†ìŒ!)
    3. ìƒˆ íŒŒì¼ ì €ì¥
    4. ë‹¤ìš´ë¡œë“œ URL ë°˜í™˜
    """
    
    # ê¸°ì¡´ íŒŒì¼ ê²½ë¡œ ì¡°íšŒ
    original_path = await db.get_ppt_path(ppt_id)
    
    # ìŠ¤íƒ€ì¼ ì¬ì ìš©
    applicator = StyleApplicator()
    new_path = await applicator.reapply_style(original_path, new_style)
    
    # ìƒˆ PPT ID ìƒì„±
    new_ppt_id = generate_unique_id()
    
    # DB ì €ì¥
    await db.save_ppt_info(new_ppt_id, {
        "path": new_path,
        "style": new_style,
        "parent_id": ppt_id
    })
    
    return {
        "new_ppt_id": new_ppt_id,
        "download_url": f"/download/{new_ppt_id}",
        "processing_time": "2.7ì´ˆ"  # ì‹¤ì œ ì¸¡ì •ê°’
    }
```

---

# ğŸ“‹ Week 2: ë°œí‘œ ì¤€ë¹„ ì§€ì›

## Task 2.1: AI ë°œí‘œì ë…¸íŠ¸ ìƒì„±ê¸° (Day 1-2)

### íŒŒì¼: `app/services/speaker_notes_generator.py` (ì‹ ê·œ)

```python
"""
AI ê¸°ë°˜ ë°œí‘œì ë…¸íŠ¸ ìë™ ìƒì„±
"""

from typing import Dict, List
import json

class SpeakerNotesGenerator:
    """ìŠ¬ë¼ì´ë“œë³„ ë°œí‘œ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"""
    
    def __init__(self):
        self.llm_client = LLMClient(model="gpt-4-turbo")
    
    async def generate_notes(
        self, 
        slide_spec: Dict,
        slide_number: int,
        total_slides: int,
        context: Dict  # ì „ì²´ í”„ë ˆì  í…Œì´ì…˜ ë§¥ë½
    ) -> Dict:
        """
        ë°œí‘œì ë…¸íŠ¸ ìƒì„±
        
        Returns:
            {
                "opening": "ë„ì… ë©˜íŠ¸ (5ì´ˆ)",
                "key_points": ["í¬ì¸íŠ¸ 1", "í¬ì¸íŠ¸ 2", "í¬ì¸íŠ¸ 3"],
                "transition": "ë‹¤ìŒ ìŠ¬ë¼ì´ë“œ ì „í™˜ ë©˜íŠ¸",
                "timing": 45,  # ê¶Œì¥ ë°œí‘œ ì‹œê°„ (ì´ˆ)
                "emphasis": ["ê°•ì¡°í•  ìˆ«ì", "ê°•ì¡°í•  í‚¤ì›Œë“œ"]
            }
        """
        
        prompt = self._build_prompt(
            slide_spec, 
            slide_number, 
            total_slides, 
            context
        )
        
        response = await self.llm_client.generate(prompt)
        notes = json.loads(response)
        
        return notes
    
    def _build_prompt(
        self, 
        slide_spec: Dict, 
        slide_number: int,
        total_slides: int,
        context: Dict
    ) -> str:
        """í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        
        # ì´ì „/ë‹¤ìŒ ìŠ¬ë¼ì´ë“œ ì œëª© (ë§¥ë½ ì œê³µ)
        prev_title = context.get("prev_slide_title", "")
        next_title = context.get("next_slide_title", "")
        
        return f"""
ë‹¹ì‹ ì€ McKinsey ì‹œë‹ˆì–´ íŒŒíŠ¸ë„ˆì…ë‹ˆë‹¤.
ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì— ëŒ€í•œ ë°œí‘œ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‘ì„±í•˜ì„¸ìš”.

## ìŠ¬ë¼ì´ë“œ ì •ë³´
- ë²ˆí˜¸: {slide_number} / {total_slides}
- ì œëª©: {slide_spec['headline']}
- ì½˜í…ì¸ : {slide_spec['content']}
- ì°¨íŠ¸: {slide_spec.get('chart_type', 'None')}

## ë§¥ë½
- ì´ì „ ìŠ¬ë¼ì´ë“œ: {prev_title}
- ë‹¤ìŒ ìŠ¬ë¼ì´ë“œ: {next_title}

## ì‘ì„± ì§€ì¹¨
1. **ë„ì… ë©˜íŠ¸** (5-10ì´ˆ)
   - ì´ì „ ìŠ¬ë¼ì´ë“œì™€ ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°
   - ì²­ì¤‘ì˜ ê´€ì‹¬ ëŒê¸°

2. **í•µì‹¬ í¬ì¸íŠ¸** (30-40ì´ˆ)
   - 3ê°€ì§€ í•µì‹¬ ë©”ì‹œì§€
   - ë°ì´í„° ìˆ˜ì¹˜ êµ¬ì²´ì ìœ¼ë¡œ ì–¸ê¸‰
   - "So What?" ëª…í™•íˆ ì „ë‹¬

3. **ì „í™˜ ë©˜íŠ¸** (5ì´ˆ)
   - ë‹¤ìŒ ìŠ¬ë¼ì´ë“œ ì˜ˆê³ 
   - ì²­ì¤‘ì˜ ê¸°ëŒ€ê° ìœ ë°œ

4. **ê°•ì¡° í¬ì¸íŠ¸**
   - íŠ¹íˆ ê°•ì¡°í•´ì•¼ í•  ìˆ«ì/í‚¤ì›Œë“œ
   - ìŒì„± í†¤ ì¡°ì ˆ ì§€ì 

5. **íƒ€ì´ë°**
   - ê¶Œì¥ ë°œí‘œ ì‹œê°„ (ì´ˆ ë‹¨ìœ„)
   - ë„ˆë¬´ ë¹ ë¥´ê±°ë‚˜ ëŠë¦¬ì§€ ì•Šê²Œ

## ì¶œë ¥ í˜•ì‹ (JSONë§Œ)
{{
    "opening": "ì´ì „ ìŠ¬ë¼ì´ë“œì—ì„œ ë¬¸ì œë¥¼ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì´ì œ í•´ê²°ì±…ì„ ë³´ì‹œê² ìŠµë‹ˆë‹¤.",
    "key_points": [
        "ì²« ë²ˆì§¸ë¡œ, ì‹œì¥ ì ìœ ìœ¨ì´ 25%ì—ì„œ 40%ë¡œ ì¦ê°€í–ˆìŠµë‹ˆë‹¤",
        "ë‘ ë²ˆì§¸ë¡œ, ì´ëŠ” ì‹ ì œí’ˆ ë¼ì¸ì´ 70% ê¸°ì—¬í–ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤",
        "ì„¸ ë²ˆì§¸ë¡œ, ì´ ì¶”ì„¸ëŠ” í–¥í›„ 2ë…„ê°„ ì§€ì†ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤"
    ],
    "transition": "ì´ëŸ¬í•œ ì„±ì¥ì„ ì§€ì†í•˜ê¸° ìœ„í•œ 3ê°€ì§€ ì „ëµì„ ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì—ì„œ ì œì‹œí•˜ê² ìŠµë‹ˆë‹¤",
    "timing": 45,
    "emphasis": ["40%", "70%", "2ë…„"]
}}
"""
    
    async def generate_all_notes(
        self, 
        slides: List[Dict]
    ) -> List[Dict]:
        """ì „ì²´ ìŠ¬ë¼ì´ë“œ ë°œí‘œì ë…¸íŠ¸ ìƒì„±"""
        
        all_notes = []
        total_slides = len(slides)
        
        for i, slide in enumerate(slides):
            # ë§¥ë½ ì •ë³´ êµ¬ì„±
            context = {
                "prev_slide_title": slides[i-1]["headline"] if i > 0 else "",
                "next_slide_title": slides[i+1]["headline"] if i < total_slides-1 else ""
            }
            
            notes = await self.generate_notes(
                slide, 
                i + 1, 
                total_slides,
                context
            )
            
            all_notes.append(notes)
        
        return all_notes
```

---

## Task 2.2: ì˜ˆìƒ ì§ˆë¬¸ + ë‹µë³€ ìƒì„± (Day 3-4)

### íŒŒì¼: `app/services/qa_generator.py` (ì‹ ê·œ)

```python
"""
ì˜ˆìƒ ì§ˆë¬¸ ë° ë‹µë³€ ìƒì„±
"""

from typing import Dict, List

class QAGenerator:
    """ì§ˆì˜ì‘ë‹µ ìƒì„±ê¸°"""
    
    def __init__(self):
        self.llm_client = LLMClient(model="gpt-4-turbo")
    
    async def generate_qa(
        self, 
        slide_spec: Dict,
        full_presentation: Dict
    ) -> List[Dict]:
        """
        ìŠ¬ë¼ì´ë“œë³„ ì˜ˆìƒ ì§ˆë¬¸ 3ê°œ + ë‹µë³€ ìƒì„±
        
        Returns:
            [
                {
                    "question": "ì´ ìˆ˜ì¹˜ëŠ” ì–´ë–»ê²Œ ì‚°ì¶œí–ˆë‚˜ìš”?",
                    "answer": "2023-2024 ì¬ë¬´ì œí‘œ ê¸°ë°˜ ì—°í‰ê·  ì„±ì¥ë¥ ì…ë‹ˆë‹¤",
                    "reference_slide": 5,  # ì°¸ì¡° ìŠ¬ë¼ì´ë“œ ë²ˆí˜¸
                    "difficulty": "medium"  # easy/medium/hard
                },
                ...
            ]
        """
        
        prompt = f"""
ë‹¹ì‹ ì€ ê²½ì˜ì§„ í”„ë ˆì  í…Œì´ì…˜ ê²½í—˜ì´ í’ë¶€í•œ McKinsey íŒŒíŠ¸ë„ˆì…ë‹ˆë‹¤.
ë‹¤ìŒ ìŠ¬ë¼ì´ë“œì— ëŒ€í•´ ì²­ì¤‘ì´ ë¬¼ì–´ë³¼ ê°€ëŠ¥ì„±ì´ ë†’ì€ ì§ˆë¬¸ 3ê°œë¥¼ ì˜ˆì¸¡í•˜ê³  ë‹µë³€ì„ ì¤€ë¹„í•˜ì„¸ìš”.

## ìŠ¬ë¼ì´ë“œ ì •ë³´
- ì œëª©: {slide_spec['headline']}
- ì½˜í…ì¸ : {slide_spec['content']}
- ë°ì´í„°: {slide_spec.get('data', {})}

## ì „ì²´ í”„ë ˆì  í…Œì´ì…˜ ë§¥ë½
- ì£¼ì œ: {full_presentation['title']}
- ëª©ì : {full_presentation['objective']}
- íƒ€ê²Ÿ ì²­ì¤‘: {full_presentation['audience']}

## ì§ˆë¬¸ ìœ í˜• (ë‚œì´ë„ ìˆœ)
1. **Easy**: ì‚¬ì‹¤ í™•ì¸, ì •ì˜ ì§ˆë¬¸
   - "ì´ ìˆ˜ì¹˜ì˜ ì¶œì²˜ëŠ”?"
   - "íƒ€ì„ë¼ì¸ì€ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?"

2. **Medium**: ë°©ë²•ë¡ , ë¹„êµ ì§ˆë¬¸
   - "ê²½ìŸì‚¬ì™€ ë¹„êµí•˜ë©´?"
   - "ì´ ê°€ì •ì˜ ê·¼ê±°ëŠ”?"

3. **Hard**: ì „ëµì  ì˜ì‚¬ê²°ì •, ëŒ€ì•ˆ ì‹œë‚˜ë¦¬ì˜¤
   - "Plan BëŠ” ë¬´ì—‡ì¸ê°€ìš”?"
   - "ë¦¬ìŠ¤í¬ëŠ” ì–´ë–»ê²Œ ê´€ë¦¬í•˜ë‚˜ìš”?"

## ë‹µë³€ ì‘ì„± ì§€ì¹¨
- ê°„ê²°í•˜ê³  ëª…í™•í•˜ê²Œ (30ì´ˆ ì´ë‚´)
- ê°€ëŠ¥í•œ í”„ë ˆì  í…Œì´ì…˜ ë‚´ ë‹¤ë¥¸ ìŠ¬ë¼ì´ë“œ ì°¸ì¡°
- ëª¨ë¥´ë©´ "ì¶”ê°€ ë¶„ì„ í›„ ë‹µë³€ë“œë¦¬ê² ìŠµë‹ˆë‹¤" (ì •ì§)
- ìˆ˜ì¹˜ëŠ” êµ¬ì²´ì ìœ¼ë¡œ

## ì¶œë ¥ í˜•ì‹ (JSONë§Œ)
[
    {{
        "question": "ì´ 40% ì„±ì¥ë¥ ì€ ì–´ë–»ê²Œ ì‚°ì¶œí–ˆë‚˜ìš”?",
        "answer": "2023ë…„ ë§¤ì¶œ 1,000ì–µì›ì—ì„œ 2024ë…„ 1,400ì–µì›ìœ¼ë¡œ ì¦ê°€í•œ ì‹¤ì  ê¸°ë°˜ì…ë‹ˆë‹¤. ì„¸ë¶€ ë‚´ì—­ì€ ìŠ¬ë¼ì´ë“œ 7ë²ˆ ì¬ë¬´ ë¶„ì„ì„ ì°¸ê³ í•´ì£¼ì„¸ìš”.",
        "reference_slide": 7,
        "difficulty": "medium"
    }},
    ...
]
"""
        
        response = await self.llm_client.generate(prompt)
        qa_list = json.loads(response)
        
        return qa_list
    
    async def generate_executive_qa(
        self, 
        full_presentation: Dict
    ) -> List[Dict]:
        """
        ì „ì²´ í”„ë ˆì  í…Œì´ì…˜ì— ëŒ€í•œ ê³ ë‚œë„ ì§ˆë¬¸ (CEO/CFOê¸‰)
        
        ì˜ˆì‹œ:
        - "3ë…„ í›„ ì‹œì¥ í™˜ê²½ì´ ì•…í™”ë˜ë©´?"
        - "íˆ¬ì ROI ê³„ì‚° ê·¼ê±°ëŠ”?"
        - "ì¡°ì§ ì—­ëŸ‰ì€ ì¶©ë¶„í•œê°€?"
        """
        
        prompt = f"""
CEO/CFOê¸‰ ê²½ì˜ì§„ì´ ë¬¼ì–´ë³¼ ì „ëµì  ì§ˆë¬¸ 5ê°œë¥¼ ì˜ˆì¸¡í•˜ì„¸ìš”.

## í”„ë ˆì  í…Œì´ì…˜ ìš”ì•½
{json.dumps(full_presentation, ensure_ascii=False, indent=2)}

## ì§ˆë¬¸ ìœ í˜•
1. **ì¬ë¬´ì  íƒ€ë‹¹ì„±**
   - ROI, NPV, Payback Period
   - ë¹„ìš© êµ¬ì¡°, ìˆ˜ìµ ëª¨ë¸

2. **ì „ëµì  ë¦¬ìŠ¤í¬**
   - ì‹œì¥ ë³€í™” ì‹œë‚˜ë¦¬ì˜¤
   - ê²½ìŸ ëŒ€ì‘ ì „ëµ

3. **ì‹¤í–‰ ê°€ëŠ¥ì„±**
   - ì¡°ì§ ì—­ëŸ‰
   - ë¦¬ì†ŒìŠ¤ ì¶©ë¶„ì„±
   - íƒ€ì„ë¼ì¸ í˜„ì‹¤ì„±

4. **ëŒ€ì•ˆ ë° ìµœì í™”**
   - Plan B
   - ìš°ì„ ìˆœìœ„ ì¡°ì •
   - ë‹¨ê³„ì  ì ‘ê·¼

ì¶œë ¥: JSON ë¦¬ìŠ¤íŠ¸
"""
        
        response = await self.llm_client.generate(prompt)
        return json.loads(response)
```

---

## Task 2.3: PPT íŒŒì¼ì— ìŠ¤í”¼ì»¤ ë…¸íŠ¸ ì‚½ì… (Day 5)

### íŒŒì¼: `app/services/notes_inserter.py` (ì‹ ê·œ)

```python
"""
ìƒì„±ëœ ë°œí‘œì ë…¸íŠ¸ë¥¼ PPT íŒŒì¼ì— ì‚½ì…
"""

from pptx import Presentation
from typing import List, Dict

class NotesInserter:
    """PPT íŒŒì¼ì— ë…¸íŠ¸ ì‚½ì…"""
    
    async def insert_notes(
        self, 
        ppt_path: str,
        speaker_notes: List[Dict],
        qa_pairs: List[List[Dict]]  # ìŠ¬ë¼ì´ë“œë³„ Q&A ë¦¬ìŠ¤íŠ¸
    ) -> str:
        """
        PPT íŒŒì¼ì— ë°œí‘œì ë…¸íŠ¸ ì‚½ì…
        
        Args:
            ppt_path: PPT íŒŒì¼ ê²½ë¡œ
            speaker_notes: ìŠ¬ë¼ì´ë“œë³„ ë°œí‘œì ë…¸íŠ¸
            qa_pairs: ìŠ¬ë¼ì´ë“œë³„ ì˜ˆìƒ Q&A
        
        Returns:
            str: ë…¸íŠ¸ê°€ ì‚½ì…ëœ ìƒˆ PPT íŒŒì¼ ê²½ë¡œ
        """
        
        prs = Presentation(ppt_path)
        
        for i, slide in enumerate(prs.slides):
            if i >= len(speaker_notes):
                break
            
            # ë…¸íŠ¸ í…ìŠ¤íŠ¸ êµ¬ì„±
            notes_text = self._format_notes(
                speaker_notes[i],
                qa_pairs[i] if i < len(qa_pairs) else []
            )
            
            # PPT ë…¸íŠ¸ì— ì‚½ì…
            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes_text
        
        # ìƒˆ íŒŒì¼ë¡œ ì €ì¥
        new_path = ppt_path.replace(".pptx", "_with_notes.pptx")
        prs.save(new_path)
        
        return new_path
    
    def _format_notes(
        self, 
        speaker_notes: Dict,
        qa_list: List[Dict]
    ) -> str:
        """ë…¸íŠ¸ í…ìŠ¤íŠ¸ í¬ë§·íŒ…"""
        
        text = f"""
ğŸ¤ ë°œí‘œ ìŠ¤í¬ë¦½íŠ¸ (ê¶Œì¥ ì‹œê°„: {speaker_notes['timing']}ì´ˆ)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â–¶ ë„ì… (5-10ì´ˆ)
{speaker_notes['opening']}

â–¶ í•µì‹¬ í¬ì¸íŠ¸ (30-40ì´ˆ)
"""
        
        for i, point in enumerate(speaker_notes['key_points'], 1):
            text += f"\n{i}. {point}"
        
        text += f"\n\nâ–¶ ì „í™˜ ë©˜íŠ¸ (5ì´ˆ)\n{speaker_notes['transition']}"
        
        if speaker_notes['emphasis']:
            text += f"\n\nğŸ”´ ê°•ì¡°í•  í¬ì¸íŠ¸:\n"
            for item in speaker_notes['emphasis']:
                text += f"  â€¢ {item}\n"
        
        if qa_list:
            text += "\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            text += "â“ ì˜ˆìƒ ì§ˆë¬¸ & ë‹µë³€\n\n"
            
            for j, qa in enumerate(qa_list, 1):
                text += f"{j}. Q: {qa['question']}\n"
                text += f"   A: {qa['answer']}\n"
                
                if qa.get('reference_slide'):
                    text += f"   â†’ ì°¸ì¡°: ìŠ¬ë¼ì´ë“œ {qa['reference_slide']}ë²ˆ\n"
                
                text += "\n"
        
        return text
```

### WorkflowOrchestrator í†µí•©

```python
async def execute_workflow(self, input_data: Dict, ppt_id: str) -> Dict:
    """ì›Œí¬í”Œë¡œìš°ì— ë°œí‘œì ë…¸íŠ¸ ìƒì„± ì¶”ê°€"""
    
    # ... ê¸°ì¡´ íŒŒì´í”„ë¼ì¸ ...
    
    # ë°œí‘œì ë…¸íŠ¸ ìƒì„± (ì„ íƒì )
    if input_data.get("generate_speaker_notes", True):
        notes_gen = SpeakerNotesGenerator()
        qa_gen = QAGenerator()
        
        speaker_notes = await notes_gen.generate_all_notes(
            context["content_generation"]["slides"]
        )
        
        qa_pairs = []
        for slide in context["content_generation"]["slides"]:
            qa = await qa_gen.generate_qa(slide, input_data)
            qa_pairs.append(qa)
        
        # PPTì— ì‚½ì…
        inserter = NotesInserter()
        final_ppt_path = await inserter.insert_notes(
            context["ppt_path"],
            speaker_notes,
            qa_pairs
        )
        
        context["final_ppt_path"] = final_ppt_path
        context["speaker_notes"] = speaker_notes
        context["qa_pairs"] = qa_pairs
    
    return context
```

---

