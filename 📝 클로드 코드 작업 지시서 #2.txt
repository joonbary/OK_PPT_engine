ğŸ“ í´ë¡œë“œ ì½”ë“œ ì‘ì—… ì§€ì‹œì„œ #2
ğŸ¯ ì‘ì—… ëª©í‘œ
McKinsey 4ë‹¨ê³„ Insight Ladder ì‹œìŠ¤í…œ êµ¬ì¶• (Phase 2, Day 2)
ğŸ“‚ ì‘ì—… ë””ë ‰í† ë¦¬
D:\PPT_Designer_OK

ğŸ”§ Step 1: InsightLadder í•µì‹¬ í´ë˜ìŠ¤ ìƒì„±
íŒŒì¼: app/services/insight_ladder.py
ë‹¤ìŒ êµ¬ì¡°ë¡œ íŒŒì¼ì„ ìƒì„±í•˜ì„¸ìš”:
python"""
McKinsey 4ë‹¨ê³„ ì¸ì‚¬ì´íŠ¸ ë˜ë”
Level 1: Observation (ê´€ì°°) - "ë§¤ì¶œ 10% ì¦ê°€"
Level 2: Comparison (ë¹„êµ) - "ê²½ìŸì‚¬ ëŒ€ë¹„ 2ë°°"
Level 3: Implication (ì›ì¸/ìƒê´€) - "ì‹ ì œí’ˆì´ 70% ê¸°ì—¬"
Level 4: Action (ì „ëµ/ê¶Œê³ ) - "ë¼ì¸ í™•ëŒ€ë¡œ 20% ì¶”ê°€ ì„±ì¥ ê°€ëŠ¥"
"""

from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import re
import logging

logger = logging.getLogger(__name__)


class InsightLevel(Enum):
    """ì¸ì‚¬ì´íŠ¸ ìˆ˜ì¤€"""
    OBSERVATION = 1      # "ë§¤ì¶œ 10% ì¦ê°€"
    COMPARISON = 2       # "ê²½ìŸì‚¬ ëŒ€ë¹„ 2ë°°"
    IMPLICATION = 3      # "ì‹ ì œí’ˆì´ ì›ì¸"
    ACTION = 4          # "ë¼ì¸ í™•ëŒ€ í•„ìš”"


@dataclass
class Insight:
    """ì¸ì‚¬ì´íŠ¸ ë°ì´í„°"""
    level: InsightLevel
    statement: str
    evidence: List[str]
    confidence: float
    metrics: Optional[Dict] = None


class InsightLadder:
    """
    ë°ì´í„°ë¥¼ 4ë‹¨ê³„ ì¸ì‚¬ì´íŠ¸ë¡œ ë³€í™˜
    
    McKinsey ë°©ì‹:
    1. ë°ì´í„° ê´€ì°° â†’ 2. ë¹„êµ ë¶„ì„ â†’ 3. ì›ì¸ íŒŒì•… â†’ 4. ì „ëµ ì œì‹œ
    """
    
    # ë¹„êµ í‚¤ì›Œë“œ
    COMPARISON_KEYWORDS = [
        "ëŒ€ë¹„", "ë¹„êµ", "ì°¨ì´", "ë°°", "ë°°ìˆ˜", "ì´ˆê³¼", "ë¯¸ë§Œ",
        "ë†’ì€", "ë‚®ì€", "ë¹ ë¥¸", "ëŠë¦°", "ë§ì€", "ì ì€"
    ]
    
    # ì›ì¸ í‚¤ì›Œë“œ
    IMPLICATION_KEYWORDS = [
        "ì›ì¸", "ê¸°ì—¬", "ì˜í–¥", "ê²°ê³¼", "íš¨ê³¼", "ë•Œë¬¸", "ë•ë¶„",
        "ìš”ì¸", "ì´ìœ ", "ë°°ê²½", "ê·¼ê±°", "ìƒê´€"
    ]
    
    # ì „ëµ í‚¤ì›Œë“œ
    ACTION_KEYWORDS = [
        "ì „ëµ", "í•„ìš”", "ê¶Œê³ ", "ì œì•ˆ", "ì‹¤í–‰", "ì¶”ì§„", "ê°€ëŠ¥",
        "í™•ëŒ€", "ê°•í™”", "ê°œì„ ", "íˆ¬ì", "ì§‘ì¤‘", "ì „í™˜"
    ]
    
    def __init__(self):
        """ì´ˆê¸°í™”"""
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def climb(self, data: Dict) -> List[Insight]:
        """
        ë°ì´í„°ì—ì„œ 4ë‹¨ê³„ ì¸ì‚¬ì´íŠ¸ ìƒì„±
        
        Args:
            data: ì›ë³¸ ë°ì´í„° {
                "metric": "ë§¤ì¶œ",
                "value": 1000,
                "previous_value": 900,
                "benchmark": 950,
                "period": "2024ë…„",
                "drivers": {"ì‹ ì œí’ˆ": 70, "ê¸°ì¡´ì œí’ˆ": 30}
            }
        
        Returns:
            List[Insight]: Level 1-4 ì¸ì‚¬ì´íŠ¸ ë¦¬ìŠ¤íŠ¸
        """
        insights = []
        
        try:
            # Level 1: Observation
            observation = self._create_observation(data)
            insights.append(observation)
            
            # Level 2: Comparison
            comparison = self._create_comparison(data, observation)
            insights.append(comparison)
            
            # Level 3: Implication
            implication = self._create_implication(data, comparison)
            insights.append(implication)
            
            # Level 4: Action
            action = self._create_action(data, implication)
            insights.append(action)
            
            self.logger.info(f"Generated {len(insights)} level insights")
            return insights
            
        except Exception as e:
            self.logger.error(f"Insight generation failed: {e}")
            # í´ë°±: Level 1ë§Œ ë°˜í™˜
            return [self._create_fallback_observation(data)]
    
    def _create_observation(self, data: Dict) -> Insight:
        """
        Level 1: ë‹¨ìˆœ ê´€ì°°
        ì˜ˆ: "2024ë…„ ë§¤ì¶œì´ 1000ì–µì›ì´ë‹¤"
        """
        metric = data.get("metric", "ê°’")
        value = data.get("value", 0)
        period = data.get("period", "í˜„ì¬")
        unit = data.get("unit", "")
        
        # ìˆ«ì í¬ë§·íŒ…
        formatted_value = self._format_number(value, unit)
        
        statement = f"{period} {metric}ì´ {formatted_value}"
        
        return Insight(
            level=InsightLevel.OBSERVATION,
            statement=statement,
            evidence=[f"ë°ì´í„°: {metric}={value}"],
            confidence=1.0,
            metrics={"value": value}
        )
    
    def _create_comparison(self, data: Dict, observation: Insight) -> Insight:
        """
        Level 2: ë¹„êµ ë¶„ì„
        ì˜ˆ: "ì „ë…„ ëŒ€ë¹„ 10% ì¦ê°€, ê²½ìŸì‚¬ 5% ëŒ€ë¹„ 2ë°° ë¹ ë¦„"
        """
        current = data.get("value", 0)
        previous = data.get("previous_value")
        benchmark = data.get("benchmark")
        metric = data.get("metric", "ê°’")
        
        comparisons = []
        metrics = {"value": current}
        
        # 1. ì „ë…„ ëŒ€ë¹„ ë¹„êµ
        if previous is not None and previous > 0:
            growth_rate = ((current - previous) / previous) * 100
            metrics["growth_rate"] = growth_rate
            
            if growth_rate > 0:
                comparisons.append(f"ì „ë…„ ëŒ€ë¹„ {abs(growth_rate):.1f}% ì¦ê°€")
            elif growth_rate < 0:
                comparisons.append(f"ì „ë…„ ëŒ€ë¹„ {abs(growth_rate):.1f}% ê°ì†Œ")
            else:
                comparisons.append("ì „ë…„ê³¼ ë™ì¼")
        
        # 2. ë²¤ì¹˜ë§ˆí¬ ëŒ€ë¹„ ë¹„êµ
        if benchmark is not None and benchmark > 0:
            vs_benchmark = current / benchmark
            metrics["vs_benchmark"] = vs_benchmark
            
            if vs_benchmark > 1.2:
                comparisons.append(f"ì—…ê³„ í‰ê·  ëŒ€ë¹„ {vs_benchmark:.1f}ë°° ë†’ìŒ")
            elif vs_benchmark < 0.8:
                comparisons.append(f"ì—…ê³„ í‰ê·  ëŒ€ë¹„ {(1-vs_benchmark)*100:.1f}% ë‚®ìŒ")
            else:
                comparisons.append("ì—…ê³„ í‰ê·  ìˆ˜ì¤€")
        
        # ë¹„êµ ë¬¸êµ¬ ê²°í•©
        if comparisons:
            statement = ", ".join(comparisons)
        else:
            # í´ë°±: ì ˆëŒ€ê°’ ê°•ì¡°
            formatted_value = self._format_number(current, data.get("unit", ""))
            statement = f"{metric} {formatted_value}ë¡œ ë†’ì€ ìˆ˜ì¤€"
        
        return Insight(
            level=InsightLevel.COMPARISON,
            statement=statement,
            evidence=[observation.statement],
            confidence=0.9 if comparisons else 0.6,
            metrics=metrics
        )
    
    def _create_implication(self, data: Dict, comparison: Insight) -> Insight:
        """
        Level 3: ì›ì¸/ìƒê´€ê´€ê³„
        ì˜ˆ: "ì‹ ì œí’ˆ ì¶œì‹œê°€ ë§¤ì¶œ ì„±ì¥ì˜ 70% ê¸°ì—¬"
        """
        drivers = data.get("drivers", {})
        metric = data.get("metric", "ë³€í™”")
        
        if drivers:
            # ê°€ì¥ í° ê¸°ì—¬ ìš”ì¸ ì°¾ê¸°
            main_driver = max(drivers.items(), key=lambda x: x[1])
            driver_name, contribution = main_driver
            
            statement = f"{driver_name}ì´ {metric}ì˜ {contribution:.0f}% ê¸°ì—¬"
            confidence = 0.85
            evidence = [comparison.statement, f"ê¸°ì—¬ë„ ë¶„ì„: {drivers}"]
            
        else:
            # í´ë°±: ë¹„êµ ê²°ê³¼ì—ì„œ ì¶”ë¡ 
            if "ì¦ê°€" in comparison.statement:
                statement = "ì‹œì¥ í™•ëŒ€ ë° ì œí’ˆ ê²½ìŸë ¥ ê°•í™”ê°€ ì£¼ìš” ì›ì¸"
                confidence = 0.7
            elif "ê°ì†Œ" in comparison.statement:
                statement = "ì‹œì¥ í™˜ê²½ ì•…í™” ë˜ëŠ” ê²½ìŸ ì‹¬í™”ê°€ ì£¼ìš” ì›ì¸"
                confidence = 0.7
            else:
                statement = "ë³µí•©ì  ìš”ì¸ì— ì˜í•œ ê²°ê³¼ë¡œ ì¶”ì •"
                confidence = 0.6
            
            evidence = [comparison.statement]
        
        return Insight(
            level=InsightLevel.IMPLICATION,
            statement=statement,
            evidence=evidence,
            confidence=confidence,
            metrics=comparison.metrics
        )
    
    def _create_action(self, data: Dict, implication: Insight) -> Insight:
        """
        Level 4: ì „ëµì  ê¶Œê³ 
        ì˜ˆ: "ì‹ ì œí’ˆ ë¼ì¸ 3ê°œë¡œ í™•ëŒ€í•˜ì—¬ 20% ì¶”ê°€ ì„±ì¥ ê°€ëŠ¥"
        """
        metric = data.get("metric", "ì„±ê³¼")
        current = data.get("value", 0)
        
        # ì „ëµ ë§¤í•‘
        action_statement = self._generate_action_recommendation(
            implication.statement,
            metric,
            current,
            data
        )
        
        return Insight(
            level=InsightLevel.ACTION,
            statement=action_statement,
            evidence=[implication.statement],
            confidence=0.75,
            metrics=implication.metrics
        )
    
    def _generate_action_recommendation(
        self,
        implication: str,
        metric: str,
        current_value: float,
        data: Dict
    ) -> str:
        """
        í•¨ì˜ì—ì„œ ì‹¤í–‰ ê°€ëŠ¥í•œ ê¶Œê³ ì‚¬í•­ ë„ì¶œ
        
        ë§¤í•‘ ë¡œì§:
        - "ê¸°ì—¬" â†’ í•´ë‹¹ ì˜ì—­ íˆ¬ì í™•ëŒ€
        - "ì¦ê°€" â†’ ëª¨ë©˜í…€ ìœ ì§€ ì „ëµ
        - "ê°ì†Œ" â†’ ê°œì„  ì¡°ì¹˜
        - "ê²½ìŸ" â†’ ì°¨ë³„í™” ì „ëµ
        """
        implication_lower = implication.lower()
        
        # 1. ê¸°ì—¬ ìš”ì¸ ê¸°ë°˜ ì „ëµ
        if "ê¸°ì—¬" in implication_lower:
            # ì£¼ìš” ê¸°ì—¬ì ì¶”ì¶œ
            match = re.search(r'(\w+)ì´', implication)
            if match:
                driver = match.group(1)
                return f"{driver} ì˜ì—­ íˆ¬ì í™•ëŒ€ë¡œ {metric} 30% ì¶”ê°€ ì„±ì¥ ê°€ëŠ¥"
            else:
                return f"í•µì‹¬ ì„±ì¥ ë™ë ¥ ê°•í™”ë¡œ {metric} ì§€ì† ì„±ì¥ ê°€ëŠ¥"
        
        # 2. ì¦ê°€ íŠ¸ë Œë“œ ê¸°ë°˜ ì „ëµ
        elif "ì¦ê°€" in implication_lower or "ì„±ì¥" in implication_lower:
            return f"ì„±ì¥ ëª¨ë©˜í…€ ìœ ì§€ ìœ„í•œ ì„ ì œì  íˆ¬ìë¡œ {metric} ê·¹ëŒ€í™” í•„ìš”"
        
        # 3. ê°ì†Œ íŠ¸ë Œë“œ ê¸°ë°˜ ì „ëµ
        elif "ê°ì†Œ" in implication_lower or "ì•…í™”" in implication_lower:
            return f"{metric} ê°œì„  ìœ„í•œ ì¦‰ê°ì  ëŒ€ì‘ ì¡°ì¹˜ ë° êµ¬ì¡° ê°œì„  í•„ìš”"
        
        # 4. ê²½ìŸ ê´€ë ¨ ì „ëµ
        elif "ê²½ìŸ" in implication_lower:
            return f"ê²½ìŸ ìš°ìœ„ í™•ë³´ ìœ„í•œ ì°¨ë³„í™” ì „ëµ ìˆ˜ë¦½ ë° ì‹¤í–‰ í•„ìš”"
        
        # 5. ì‹œì¥ ê´€ë ¨ ì „ëµ
        elif "ì‹œì¥" in implication_lower:
            return f"ì‹œì¥ ë³€í™” ëŒ€ì‘ ì „ëµ ë§ˆë ¨ ë° ì‹ ì†í•œ ì‹¤í–‰ í•„ìš”"
        
        # 6. ê¸°ë³¸ ì „ëµ
        else:
            return f"{metric} ìµœì í™” ìœ„í•œ ì „ëµì  ì ‘ê·¼ ë° íˆ¬ì í•„ìš”"
    
    def _format_number(self, value: float, unit: str = "") -> str:
        """ìˆ«ì í¬ë§·íŒ… (í•œêµ­ì‹)"""
        if value >= 10000:
            # ì–µ ë‹¨ìœ„
            eok = value / 10000
            if eok >= 10000:
                # ì¡° ë‹¨ìœ„
                jo = eok / 10000
                return f"{jo:.1f}ì¡°{unit}"
            return f"{eok:.1f}ì–µ{unit}"
        elif value >= 1000:
            return f"{value:,.0f}{unit}"
        else:
            return f"{value:.1f}{unit}"
    
    def _create_fallback_observation(self, data: Dict) -> Insight:
        """í´ë°± ê´€ì°° (ë°ì´í„° ì—†ì„ ë•Œ)"""
        return Insight(
            level=InsightLevel.OBSERVATION,
            statement="ë°ì´í„° ë¶„ì„ ì¤‘",
            evidence=["ì›ë³¸ ë°ì´í„° ë¶€ì¡±"],
            confidence=0.3,
            metrics={}
        )


class InsightEnhancer:
    """ê¸°ì¡´ ì½˜í…ì¸ ë¥¼ 4ë‹¨ê³„ ì¸ì‚¬ì´íŠ¸ë¡œ ê°•í™”"""
    
    def __init__(self):
        """ì´ˆê¸°í™”"""
        self.ladder = InsightLadder()
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def enhance_slide(self, slide_content: Dict) -> Dict:
        """
        ìŠ¬ë¼ì´ë“œ ì½˜í…ì¸ ë¥¼ 4ë‹¨ê³„ ì¸ì‚¬ì´íŠ¸ë¡œ ê°•í™”
        
        Before:
        - ì œëª©: "ë§¤ì¶œ í˜„í™©"
        - ë‚´ìš©: "2024ë…„ ë§¤ì¶œ 1000ì–µ"
        
        After:
        - ì œëª©: "ì‹ ì œí’ˆ ì¶œì‹œë¡œ ë§¤ì¶œ 20% ê¸‰ì¦, ì¶”ê°€ íˆ¬ì í•„ìš”"
        - ë‚´ìš©: 
            - Level 2: "ì „ë…„ ëŒ€ë¹„ 20% ì¦ê°€, ì—…ê³„ í‰ê·  ëŒ€ë¹„ 2ë°°"
            - Level 3: "ì‹ ì œí’ˆì´ 70% ê¸°ì—¬"
            - Level 4: "ì‹ ì œí’ˆ ë¼ì¸ í™•ëŒ€ë¡œ 30% ì¶”ê°€ ì„±ì¥ ê°€ëŠ¥"
        
        Args:
            slide_content: ì›ë³¸ ìŠ¬ë¼ì´ë“œ ì½˜í…ì¸ 
        
        Returns:
            Dict: ê°•í™”ëœ ìŠ¬ë¼ì´ë“œ ì½˜í…ì¸ 
        """
        try:
            # ë°ì´í„° ì¶”ì¶œ
            data = self._extract_data_from_content(slide_content)
            
            # ì¸ì‚¬ì´íŠ¸ ìƒì„±
            insights = self.ladder.climb(data)
            
            # Level 4 (Action)ë¥¼ ì œëª©ìœ¼ë¡œ ì‚¬ìš©
            enhanced_title = insights[3].statement if len(insights) >= 4 else slide_content.get("title", "ì œëª© ì—†ìŒ")
            
            # Level 2-4ë¥¼ ë³¸ë¬¸ìœ¼ë¡œ ì‚¬ìš©
            enhanced_content = []
            if len(insights) >= 4:
                enhanced_content = [
                    f"â€¢ {insights[1].statement}",  # Level 2: Comparison
                    f"â€¢ {insights[2].statement}",  # Level 3: Implication
                    f"â€¢ {insights[3].statement}"   # Level 4: Action
                ]
            else:
                # í´ë°±: ì›ë³¸ ì½˜í…ì¸  ìœ ì§€
                enhanced_content = slide_content.get("content", [])
            
            # ê²°ê³¼ ë°˜í™˜
            result = {
                **slide_content,
                "title": enhanced_title,
                "content": enhanced_content,
                "insights": [i.statement for i in insights],
                "insight_level": insights[-1].level.value if insights else 1,
                "confidence": insights[-1].confidence if insights else 0.5
            }
            
            self.logger.info(f"Enhanced slide to Level {result['insight_level']}")
            return result
            
        except Exception as e:
            self.logger.error(f"Slide enhancement failed: {e}")
            # í´ë°±: ì›ë³¸ ë°˜í™˜
            return slide_content
    
    def _extract_data_from_content(self, content: Dict) -> Dict:
        """
        ìŠ¬ë¼ì´ë“œ ì½˜í…ì¸ ì—ì„œ ë°ì´í„° ì¶”ì¶œ
        
        ì¶”ì¶œ í•­ëª©:
        - metric: ì§€í‘œëª…
        - value: í˜„ì¬ê°’
        - previous_value: ì´ì „ê°’
        - benchmark: ë²¤ì¹˜ë§ˆí¬
        - period: ê¸°ê°„
        - drivers: ê¸°ì—¬ ìš”ì¸
        """
        data = {}
        
        # 1. ëª…ì‹œì  ë°ì´í„° í•„ë“œ
        if "data" in content:
            data.update(content["data"])
        
        # 2. ì œëª©ì—ì„œ ì¶”ì¶œ
        title = content.get("title", "")
        data["metric"] = self._extract_metric_from_text(title)
        
        # 3. ë³¸ë¬¸ì—ì„œ ìˆ«ì ì¶”ì¶œ
        body = content.get("body", "")
        if isinstance(body, list):
            body = " ".join(body)
        
        numbers = self._extract_numbers_from_text(body)
        if numbers:
            data["value"] = numbers[0]
            if len(numbers) > 1:
                data["previous_value"] = numbers[1]
        
        # 4. ê¸°ë³¸ê°’ ì„¤ì •
        data.setdefault("metric", "ì§€í‘œ")
        data.setdefault("value", 100)
        data.setdefault("period", "í˜„ì¬")
        data.setdefault("unit", "")
        
        return data
    
    def _extract_metric_from_text(self, text: str) -> str:
        """í…ìŠ¤íŠ¸ì—ì„œ ì§€í‘œëª… ì¶”ì¶œ"""
        # ì¼ë°˜ì ì¸ ì§€í‘œ í‚¤ì›Œë“œ
        metrics = [
            "ë§¤ì¶œ", "ìˆ˜ìµ", "ì´ìµ", "ë¹„ìš©", "ì‹œì¥", "ì ìœ ìœ¨",
            "ì„±ì¥ë¥ ", "ë§Œì¡±ë„", "íš¨ìœ¨", "ìƒì‚°ì„±", "í’ˆì§ˆ"
        ]
        
        for metric in metrics:
            if metric in text:
                return metric
        
        # í´ë°±: ì²« ë‹¨ì–´
        words = text.split()
        return words[0] if words else "ì§€í‘œ"
    
    def _extract_numbers_from_text(self, text: str) -> List[float]:
        """í…ìŠ¤íŠ¸ì—ì„œ ìˆ«ì ì¶”ì¶œ"""
        # ìˆ«ì íŒ¨í„´ (í¼ì„¼íŠ¸, ë°°ìˆ˜, ì–µ ë“± í¬í•¨)
        patterns = [
            r'(\d+\.?\d*)\s*%',
            r'(\d+\.?\d*)\s*ë°°',
            r'(\d+\.?\d*)\s*ì–µ',
            r'(\d+\.?\d*)\s*ì¡°',
            r'(\d+\.?\d*)'
        ]
        
        numbers = []
        for pattern in patterns:
            matches = re.findall(pattern, text)
            for match in matches:
                try:
                    numbers.append(float(match))
                except ValueError:
                    continue
        
        return numbers


class InsightQualityEvaluator:
    """ì¸ì‚¬ì´íŠ¸ í’ˆì§ˆ í‰ê°€"""
    
    def evaluate(self, insights: List[Insight]) -> Dict[str, any]:
        """
        ì¸ì‚¬ì´íŠ¸ ë¦¬ìŠ¤íŠ¸ í’ˆì§ˆ í‰ê°€
        
        í‰ê°€ ê¸°ì¤€:
        1. ë ˆë²¨ ë„ë‹¬ë„ (ìµœê³  ë ˆë²¨)
        2. ì‹ ë¢°ë„ í‰ê· 
        3. ì¦ê±° ì¶©ë¶„ì„±
        4. ì •ëŸ‰í™” í¬í•¨
        
        Returns:
            {
                "score": float (0-1),
                "max_level": int (1-4),
                "avg_confidence": float,
                "has_quantification": bool,
                "quality_grade": str ("A"/"B"/"C"/"D")
            }
        """
        if not insights:
            return {
                "score": 0.0,
                "max_level": 0,
                "avg_confidence": 0.0,
                "has_quantification": False,
                "quality_grade": "F"
            }
        
        # 1. ìµœê³  ë ˆë²¨
        max_level = max(i.level.value for i in insights)
        
        # 2. í‰ê·  ì‹ ë¢°ë„
        avg_confidence = sum(i.confidence for i in insights) / len(insights)
        
        # 3. ì •ëŸ‰í™” í¬í•¨ ì—¬ë¶€
        has_quantification = any(
            re.search(r'\d+', i.statement) for i in insights
        )
        
        # 4. ì¢…í•© ì ìˆ˜ ê³„ì‚°
        score = (
            (max_level / 4.0) * 0.4 +      # ë ˆë²¨ (40%)
            avg_confidence * 0.3 +          # ì‹ ë¢°ë„ (30%)
            (1.0 if has_quantification else 0.5) * 0.3  # ì •ëŸ‰í™” (30%)
        )
        
        # 5. ë“±ê¸‰ ê²°ì •
        if score >= 0.9:
            grade = "A"
        elif score >= 0.8:
            grade = "B"
        elif score >= 0.7:
            grade = "C"
        elif score >= 0.6:
            grade = "D"
        else:
            grade = "F"
        
        return {
            "score": score,
            "max_level": max_level,
            "avg_confidence": avg_confidence,
            "has_quantification": has_quantification,
            "quality_grade": grade
        }

âœ… ì‘ì—… ì™„ë£Œ í›„ í™•ì¸ ì‚¬í•­

íŒŒì¼ ìƒì„± í™•ì¸

bash   ls app/services/insight_ladder.py

êµ¬ë¬¸ ì˜¤ë¥˜ í™•ì¸

bash   python -m py_compile app/services/insight_ladder.py

ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰

python   from app.services.insight_ladder import InsightLadder, InsightEnhancer
   
   # í…ŒìŠ¤íŠ¸ ë°ì´í„°
   data = {
       "metric": "ë§¤ì¶œ",
       "value": 1000,
       "previous_value": 900,
       "benchmark": 950,
       "period": "2024ë…„",
       "unit": "ì–µì›",
       "drivers": {"ì‹ ì œí’ˆ": 70, "ê¸°ì¡´ì œí’ˆ": 30}
   }
   
   # 4ë‹¨ê³„ ì¸ì‚¬ì´íŠ¸ ìƒì„±
   ladder = InsightLadder()
   insights = ladder.climb(data)
   
   print("=== 4ë‹¨ê³„ ì¸ì‚¬ì´íŠ¸ ===")
   for insight in insights:
       print(f"Level {insight.level.value}: {insight.statement}")
   
   # ìŠ¬ë¼ì´ë“œ ê°•í™” í…ŒìŠ¤íŠ¸
   slide_content = {
       "title": "ë§¤ì¶œ í˜„í™©",
       "body": "2024ë…„ ë§¤ì¶œ 1000ì–µì›",
       "data": data
   }
   
   enhancer = InsightEnhancer()
   enhanced = enhancer.enhance_slide(slide_content)
   
   print("\n=== ê°•í™”ëœ ìŠ¬ë¼ì´ë“œ ===")
   print(f"ì œëª©: {enhanced['title']}")
   print(f"ë‚´ìš©:")
   for line in enhanced['content']:
       print(f"  {line}")

ì´ ì‘ì—…ì„ ì™„ë£Œí•˜ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ê² ìŠµë‹ˆë‹¤:

Step 2: ContentGenerator í†µí•©
Step 3: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± (15ê°œ ì¼€ì´ìŠ¤)

ì‘ì—…ì„ ì§„í–‰í•´ì£¼ì„¸ìš”! ğŸš€