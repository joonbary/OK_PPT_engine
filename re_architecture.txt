# 🎯 시스템 구조 개선 제안 및 작업지시서

풀스택 개발자 + 디자이너로서 분석한 결과, **단계별 분리 접근은 매우 현명한 선택**입니다. 현재 시스템의 개선이 필요한 이유와 구체적인 실행 방안을 제시합니다.

---

## 📊 현재 시스템 문제점 분석

### 🔴 Current State (한 번에 처리)
```python
# 현재: 모든 것이 하나의 큰 파이프라인
async def execute(self, input_data: Dict) -> Dict:
    context = {"input": input_data}
    
    for stage in self.stages:  # 🚨 한 번에 모두 실행
        stage_result = await self._execute_stage(stage, context)
        context[stage] = stage_result
        
        if not self._quality_check(stage_result):
            # 🚨 어느 단계에서 문제가 생겼는지 파악 어려움
            context[stage] = await self._improve_stage(stage, stage_result)
    
    return context
```

**문제점:**
1. ❌ **디버깅 지옥**: 5단계 중 어디서 실패했는지 추적 어려움
2. ❌ **재실행 불가**: 3단계 실패 시 1-2단계 다시 실행 (비용/시간 낭비)
3. ❌ **검증 어려움**: 각 단계 결과물 중간 확인 불가
4. ❌ **병목 파악 불가**: 어느 단계가 느린지 측정 어려움
5. ❌ **개선 어려움**: 특정 단계만 개선/교체 불가

---

## ✅ 제안: 단계별 분리 아키텍처

### 🟢 Improved State (단계별 API)

```
┌─────────────────────────────────────────────────────────┐
│              Phase-Based Architecture                    │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  POST /api/v1/analyze          → Phase 1: 문서 분석     │
│       ↓ (저장: Redis/DB)                                 │
│  POST /api/v1/structure        → Phase 2: 구조 설계     │
│       ↓ (저장: Redis/DB)                                 │
│  POST /api/v1/content          → Phase 3: 콘텐츠 생성   │
│       ↓ (저장: Redis/DB)                                 │
│  POST /api/v1/design           → Phase 4: 디자인 적용   │
│       ↓ (저장: Redis/DB)                                 │
│  POST /api/v1/review           → Phase 5: 품질 검토     │
│       ↓                                                  │
│  GET  /api/v1/export/{id}      → PPT 다운로드          │
│                                                          │
│  GET  /api/v1/status/{phase_id} → 각 단계 상태 조회    │
│  POST /api/v1/retry/{phase_id}  → 특정 단계 재실행     │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

---

## 🚀 클로드 코드를 위한 작업지시서

### 📋 Task 5.1: 단계별 API 분리 아키텍처 구축

**작업 ID:** `PHASE-SEPARATION-2025-01`  
**우선순위:** 🔥 최우선  
**예상 소요 시간:** 2-3일  
**복잡도:** 중간

---

#### 🎯 작업 목표
현재 한 번에 실행되는 WorkflowOrchestrator를 5개의 독립적인 API 엔드포인트로 분리하여, 각 단계별로 실행/검증/재시도가 가능한 시스템 구축

---

#### 📁 작업 디렉토리 구조

```
D:\PPT_Designer_OK/
├── app/
│   ├── api/
│   │   └── v1/
│   │       ├── __init__.py
│   │       ├── phase_endpoints.py     # 🆕 생성 필요
│   │       └── legacy_endpoints.py    # 기존 API (유지)
│   │
│   ├── core/
│   │   ├── phase_manager.py           # 🆕 생성 필요
│   │   ├── state_manager.py           # 🆕 생성 필요
│   │   └── phase_logger.py            # 🆕 생성 필요
│   │
│   ├── models/
│   │   └── phase_models.py            # 🆕 생성 필요
│   │
│   └── services/
│       └── (기존 파일들 유지)
│
└── tests/
    └── test_phase_separation.py       # 🆕 생성 필요
```

---

### 🔧 Step 1: 상태 관리 시스템 구축 (Day 1)

**파일:** `app/core/state_manager.py`

```python
"""
단계별 실행 상태를 관리하는 핵심 시스템
각 Phase의 입력/출력/상태를 Redis와 PostgreSQL에 저장
"""

from typing import Dict, Optional, List
from datetime import datetime
from enum import Enum
import json
import redis
from sqlalchemy.orm import Session

class PhaseStatus(Enum):
    """각 Phase의 실행 상태"""
    PENDING = "pending"          # 대기 중
    RUNNING = "running"          # 실행 중
    COMPLETED = "completed"      # 완료
    FAILED = "failed"            # 실패
    SKIPPED = "skipped"          # 건너뜀

class PhaseName(Enum):
    """5단계 Phase 정의"""
    ANALYZE = "analyze"          # Phase 1: 문서 분석
    STRUCTURE = "structure"      # Phase 2: 구조 설계
    CONTENT = "content"          # Phase 3: 콘텐츠 생성
    DESIGN = "design"            # Phase 4: 디자인 적용
    REVIEW = "review"            # Phase 5: 품질 검토

class StateManager:
    """
    Phase 상태 관리 매니저
    
    핵심 기능:
    1. Phase 결과 저장/조회
    2. 상태 추적
    3. 캐시 관리
    4. 롤백 지원
    """
    
    def __init__(self, redis_client: redis.Redis, db_session: Session):
        self.redis = redis_client
        self.db = db_session
        self.cache_ttl = 3600  # 1시간
    
    async def save_phase_result(
        self,
        project_id: str,
        phase: PhaseName,
        result: Dict,
        execution_time: float
    ) -> str:
        """
        Phase 실행 결과 저장
        
        Args:
            project_id: 프로젝트 고유 ID
            phase: Phase 이름
            result: 실행 결과 데이터
            execution_time: 실행 소요 시간 (초)
        
        Returns:
            phase_result_id: 저장된 결과 ID
        """
        
        # 1. Redis에 캐시 (빠른 조회용)
        cache_key = f"phase:{project_id}:{phase.value}"
        cache_data = {
            "result": result,
            "status": PhaseStatus.COMPLETED.value,
            "timestamp": datetime.utcnow().isoformat(),
            "execution_time": execution_time
        }
        
        await self.redis.setex(
            cache_key,
            self.cache_ttl,
            json.dumps(cache_data)
        )
        
        # 2. PostgreSQL에 영구 저장
        phase_record = PhaseResult(
            project_id=project_id,
            phase_name=phase.value,
            result_data=result,
            status=PhaseStatus.COMPLETED.value,
            execution_time=execution_time,
            created_at=datetime.utcnow()
        )
        
        self.db.add(phase_record)
        self.db.commit()
        
        return phase_record.id
    
    async def get_phase_result(
        self,
        project_id: str,
        phase: PhaseName
    ) -> Optional[Dict]:
        """
        Phase 결과 조회 (캐시 우선)
        
        Returns:
            Dict 또는 None (결과가 없으면)
        """
        
        # 1. Redis 캐시 먼저 확인
        cache_key = f"phase:{project_id}:{phase.value}"
        cached = await self.redis.get(cache_key)
        
        if cached:
            return json.loads(cached)
        
        # 2. DB에서 조회
        record = self.db.query(PhaseResult).filter(
            PhaseResult.project_id == project_id,
            PhaseResult.phase_name == phase.value
        ).order_by(PhaseResult.created_at.desc()).first()
        
        if record:
            return {
                "result": record.result_data,
                "status": record.status,
                "timestamp": record.created_at.isoformat(),
                "execution_time": record.execution_time
            }
        
        return None
    
    async def update_phase_status(
        self,
        project_id: str,
        phase: PhaseName,
        status: PhaseStatus,
        error_message: Optional[str] = None
    ):
        """Phase 상태 업데이트"""
        
        cache_key = f"phase:{project_id}:{phase.value}:status"
        status_data = {
            "status": status.value,
            "timestamp": datetime.utcnow().isoformat(),
            "error": error_message
        }
        
        await self.redis.setex(
            cache_key,
            self.cache_ttl,
            json.dumps(status_data)
        )
    
    async def get_project_timeline(self, project_id: str) -> List[Dict]:
        """
        프로젝트 전체 타임라인 조회
        
        Returns:
            [
                {
                    "phase": "analyze",
                    "status": "completed",
                    "execution_time": 2.3,
                    "timestamp": "2025-01-02T10:30:00"
                },
                ...
            ]
        """
        
        records = self.db.query(PhaseResult).filter(
            PhaseResult.project_id == project_id
        ).order_by(PhaseResult.created_at.asc()).all()
        
        return [
            {
                "phase": r.phase_name,
                "status": r.status,
                "execution_time": r.execution_time,
                "timestamp": r.created_at.isoformat()
            }
            for r in records
        ]
```

**검증 방법:**
```bash
# StateManager 테스트
pytest tests/test_state_manager.py -v

# 기대 결과:
# ✅ Phase 결과 저장 성공
# ✅ Redis 캐시 작동
# ✅ DB 영구 저장 확인
# ✅ 타임라인 조회 성공
```

---

### 🔧 Step 2: Phase Manager 구현 (Day 1)

**파일:** `app/core/phase_manager.py`

```python
"""
각 Phase의 실행을 관리하는 매니저
의존성 체크, 순서 검증, 재시도 로직 포함
"""

from typing import Dict, Optional
from app.services.workflow_orchestrator import WorkflowOrchestrator
from app.core.state_manager import StateManager, PhaseName, PhaseStatus

class PhaseManager:
    """
    Phase 실행 매니저
    
    역할:
    1. Phase 순서 검증 (analyze → structure → content → design → review)
    2. 이전 Phase 완료 확인
    3. 각 Phase 실행
    4. 에러 처리 및 재시도
    """
    
    # Phase 의존성 정의
    PHASE_DEPENDENCIES = {
        PhaseName.ANALYZE: [],                           # 의존성 없음
        PhaseName.STRUCTURE: [PhaseName.ANALYZE],        # analyze 필요
        PhaseName.CONTENT: [PhaseName.STRUCTURE],        # structure 필요
        PhaseName.DESIGN: [PhaseName.CONTENT],           # content 필요
        PhaseName.REVIEW: [PhaseName.DESIGN]             # design 필요
    }
    
    def __init__(
        self,
        state_manager: StateManager,
        workflow_orchestrator: WorkflowOrchestrator
    ):
        self.state_manager = state_manager
        self.orchestrator = workflow_orchestrator
    
    async def execute_phase(
        self,
        project_id: str,
        phase: PhaseName,
        force: bool = False
    ) -> Dict:
        """
        특정 Phase 실행
        
        Args:
            project_id: 프로젝트 ID
            phase: 실행할 Phase
            force: True면 의존성 체크 무시
        
        Returns:
            {
                "success": True/False,
                "phase": "analyze",
                "result": {...},
                "execution_time": 2.3,
                "error": None or "에러 메시지"
            }
        """
        
        # 1. 의존성 체크
        if not force:
            can_run, missing = await self._check_dependencies(project_id, phase)
            if not can_run:
                return {
                    "success": False,
                    "error": f"필수 Phase 미완료: {missing}"
                }
        
        # 2. 상태 업데이트: RUNNING
        await self.state_manager.update_phase_status(
            project_id, phase, PhaseStatus.RUNNING
        )
        
        # 3. Phase 실행
        try:
            import time
            start_time = time.time()
            
            # 각 Phase별 실행 메서드 호출
            result = await self._execute_phase_logic(project_id, phase)
            
            execution_time = time.time() - start_time
            
            # 4. 결과 저장
            await self.state_manager.save_phase_result(
                project_id, phase, result, execution_time
            )
            
            # 5. 상태 업데이트: COMPLETED
            await self.state_manager.update_phase_status(
                project_id, phase, PhaseStatus.COMPLETED
            )
            
            return {
                "success": True,
                "phase": phase.value,
                "result": result,
                "execution_time": execution_time,
                "error": None
            }
            
        except Exception as e:
            # 에러 처리
            await self.state_manager.update_phase_status(
                project_id, phase, PhaseStatus.FAILED, str(e)
            )
            
            return {
                "success": False,
                "phase": phase.value,
                "error": str(e),
                "execution_time": time.time() - start_time
            }
    
    async def _check_dependencies(
        self,
        project_id: str,
        phase: PhaseName
    ) -> tuple[bool, List[str]]:
        """
        의존성 체크
        
        Returns:
            (실행 가능 여부, 누락된 Phase 목록)
        """
        
        required_phases = self.PHASE_DEPENDENCIES[phase]
        missing = []
        
        for required in required_phases:
            result = await self.state_manager.get_phase_result(
                project_id, required
            )
            
            if not result or result["status"] != PhaseStatus.COMPLETED.value:
                missing.append(required.value)
        
        return (len(missing) == 0, missing)
    
    async def _execute_phase_logic(
        self,
        project_id: str,
        phase: PhaseName
    ) -> Dict:
        """
        각 Phase별 실제 실행 로직
        """
        
        if phase == PhaseName.ANALYZE:
            # Phase 1: 문서 분석
            return await self.orchestrator.analyze_document(project_id)
        
        elif phase == PhaseName.STRUCTURE:
            # Phase 2: 구조 설계
            analyze_result = await self.state_manager.get_phase_result(
                project_id, PhaseName.ANALYZE
            )
            return await self.orchestrator.design_structure(
                analyze_result["result"]
            )
        
        elif phase == PhaseName.CONTENT:
            # Phase 3: 콘텐츠 생성
            structure_result = await self.state_manager.get_phase_result(
                project_id, PhaseName.STRUCTURE
            )
            return await self.orchestrator.generate_content(
                structure_result["result"]
            )
        
        elif phase == PhaseName.DESIGN:
            # Phase 4: 디자인 적용
            content_result = await self.state_manager.get_phase_result(
                project_id, PhaseName.CONTENT
            )
            return await self.orchestrator.apply_design(
                content_result["result"]
            )
        
        elif phase == PhaseName.REVIEW:
            # Phase 5: 품질 검토
            design_result = await self.state_manager.get_phase_result(
                project_id, PhaseName.DESIGN
            )
            return await self.orchestrator.review_quality(
                design_result["result"]
            )
```

---

### 🔧 Step 3: API 엔드포인트 생성 (Day 2)

**파일:** `app/api/v1/phase_endpoints.py`

```python
"""
단계별 실행을 위한 RESTful API 엔드포인트
"""

from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel
from typing import Optional

router = APIRouter(prefix="/api/v1", tags=["Phase-Based Processing"])

class PhaseExecuteRequest(BaseModel):
    """Phase 실행 요청"""
    project_id: str
    phase: str  # "analyze", "structure", "content", "design", "review"
    force: bool = False  # True면 의존성 무시

class PhaseResponse(BaseModel):
    """Phase 응답"""
    success: bool
    project_id: str
    phase: str
    status: str
    execution_time: Optional[float] = None
    error: Optional[str] = None
    next_phase: Optional[str] = None

@router.post("/phases/execute", response_model=PhaseResponse)
async def execute_phase(
    request: PhaseExecuteRequest,
    phase_manager: PhaseManager
):
    """
    특정 Phase 실행
    
    사용 예시:
    ```
    POST /api/v1/phases/execute
    {
        "project_id": "abc123",
        "phase": "analyze",
        "force": false
    }
    ```
    """
    
    try:
        phase_enum = PhaseName(request.phase)
    except ValueError:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid phase: {request.phase}. " + 
                   f"Must be one of: {[p.value for p in PhaseName]}"
        )
    
    result = await phase_manager.execute_phase(
        request.project_id,
        phase_enum,
        request.force
    )
    
    # 다음 Phase 제안
    next_phase = _get_next_phase(phase_enum) if result["success"] else None
    
    return PhaseResponse(
        success=result["success"],
        project_id=request.project_id,
        phase=request.phase,
        status="completed" if result["success"] else "failed",
        execution_time=result.get("execution_time"),
        error=result.get("error"),
        next_phase=next_phase
    )

@router.get("/phases/status/{project_id}")
async def get_project_status(
    project_id: str,
    state_manager: StateManager
):
    """
    프로젝트의 모든 Phase 상태 조회
    
    응답:
    ```json
    {
        "project_id": "abc123",
        "phases": [
            {
                "phase": "analyze",
                "status": "completed",
                "execution_time": 2.3,
                "timestamp": "2025-01-02T10:30:00"
            },
            {
                "phase": "structure",
                "status": "running",
                "execution_time": null,
                "timestamp": "2025-01-02T10:32:00"
            }
        ],
        "current_phase": "structure",
        "overall_progress": 40
    }
    ```
    """
    
    timeline = await state_manager.get_project_timeline(project_id)
    
    # 현재 진행 중인 Phase 찾기
    current_phase = None
    for item in reversed(timeline):
        if item["status"] in ["running", "pending"]:
            current_phase = item["phase"]
            break
    
    # 전체 진행률 계산 (5단계 기준)
    completed_count = sum(
        1 for item in timeline 
        if item["status"] == "completed"
    )
    overall_progress = (completed_count / 5) * 100
    
    return {
        "project_id": project_id,
        "phases": timeline,
        "current_phase": current_phase,
        "overall_progress": overall_progress
    }

@router.post("/phases/retry/{project_id}/{phase}")
async def retry_phase(
    project_id: str,
    phase: str,
    phase_manager: PhaseManager
):
    """
    실패한 Phase 재실행
    
    사용 시나리오:
    - Phase 3 (content)에서 실패
    - 문제 수정 후
    - POST /api/v1/phases/retry/abc123/content
    - Phase 3만 다시 실행 (1-2단계 재실행 불필요!)
    """
    
    try:
        phase_enum = PhaseName(phase)
    except ValueError:
        raise HTTPException(400, f"Invalid phase: {phase}")
    
    result = await phase_manager.execute_phase(
        project_id,
        phase_enum,
        force=True  # 재시도는 의존성 무시
    )
    
    return {
        "success": result["success"],
        "message": f"Phase {phase} 재실행 완료" if result["success"] 
                   else f"재실행 실패: {result['error']}"
    }

@router.post("/phases/execute-all/{project_id}")
async def execute_all_phases(
    project_id: str,
    background_tasks: BackgroundTasks,
    phase_manager: PhaseManager
):
    """
    모든 Phase 순차 실행 (기존 동작과 동일)
    
    하지만 이제는:
    - 각 단계별로 상태 저장
    - 중간 결과 조회 가능
    - 실패 시 해당 단계만 재시도 가능
    """
    
    async def run_all():
        for phase in PhaseName:
            result = await phase_manager.execute_phase(project_id, phase)
            if not result["success"]:
                break
    
    background_tasks.add_task(run_all)
    
    return {
        "message": "모든 Phase 실행 시작",
        "project_id": project_id,
        "status_url": f"/api/v1/phases/status/{project_id}"
    }

def _get_next_phase(current: PhaseName) -> Optional[str]:
    """다음 Phase 반환"""
    phases = list(PhaseName)
    try:
        idx = phases.index(current)
        return phases[idx + 1].value if idx < len(phases) - 1 else None
    except (ValueError, IndexError):
        return None
```

---

### 🔧 Step 4: 상세 로깅 시스템 (Day 2)

**파일:** `app/core/phase_logger.py`

```python
"""
각 Phase별 상세 로깅 시스템
디버깅, 성능 분석, 감사 추적 지원
"""

import logging
from datetime import datetime
from typing import Dict, Any
import json
from pathlib import Path

class PhaseLogger:
    """
    Phase별 구조화된 로깅
    
    로그 레벨:
    - DEBUG: 상세 실행 과정
    - INFO: 주요 이벤트
    - WARNING: 주의 필요
    - ERROR: 에러 발생
    """
    
    def __init__(self, log_dir: str = "logs"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(exist_ok=True)
        
        # 각 Phase별 로거 생성
        self.loggers = {}
        for phase in PhaseName:
            self.loggers[phase] = self._create_logger(phase.value)
    
    def _create_logger(self, phase_name: str) -> logging.Logger:
        """Phase별 로거 생성"""
        
        logger = logging.getLogger(f"phase.{phase_name}")
        logger.setLevel(logging.DEBUG)
        
        # 파일 핸들러 (JSON 형식)
        log_file = self.log_dir / f"{phase_name}.log"
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.DEBUG)
        
        # 포맷터
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        
        return logger
    
    def log_phase_start(
        self,
        phase: PhaseName,
        project_id: str,
        input_data: Dict
    ):
        """Phase 시작 로그"""
        
        logger = self.loggers[phase]
        logger.info(
            f"[START] Phase: {phase.value} | "
            f"Project: {project_id} | "
            f"Input: {json.dumps(input_data, ensure_ascii=False)[:200]}"
        )
    
    def log_phase_complete(
        self,
        phase: PhaseName,
        project_id: str,
        execution_time: float,
        result_summary: Dict
    ):
        """Phase 완료 로그"""
        
        logger = self.loggers[phase]
        logger.info(
            f"[COMPLETE] Phase: {phase.value} | "
            f"Project: {project_id} | "
            f"Time: {execution_time:.2f}s | "
            f"Result: {json.dumps(result_summary, ensure_ascii=False)[:200]}"
        )
    
    def log_phase_error(
        self,
        phase: PhaseName,
        project_id: str,
        error: Exception,
        context: Dict
    ):
        """Phase 에러 로그"""
        
        logger = self.loggers[phase]
        logger.error(
            f"[ERROR] Phase: {phase.value} | "
            f"Project: {project_id} | "
            f"Error: {str(error)} | "
            f"Context: {json.dumps(context, ensure_ascii=False)}"
        )
    
    def log_agent_call(
        self,
        phase: PhaseName,
        agent_name: str,
        input_tokens: int,
        output_tokens: int,
        cost: float
    ):
        """LLM Agent 호출 로그"""
        
        logger = self.loggers[phase]
        logger.debug(
            f"[AGENT] {agent_name} | "
            f"Tokens: {input_tokens}/{output_tokens} | "
            f"Cost: ${cost:.4f}"
        )
```

---

## 📊 변경 전후 비교

### Before (현재)
```python
# ❌ 문제 상황
result = await workflow_engine.execute(input_data)

# 🚨 Phase 3에서 실패했는데...
# - 어디서 실패했는지 추적 어려움
# - Phase 1-2 결과 확인 불가
# - 전체 다시 실행해야 함 (비용 낭비)
# - 로그가 섞여서 디버깅 어려움
```

### After (개선)
```python
# ✅ 개선된 방식

# 1단계: 문서 분석
result1 = await execute_phase("analyze")
# ✅ 결과 저장됨
# ✅ 로그 파일: logs/analyze.log

# 2단계: 구조 설계  
result2 = await execute_phase("structure")
# ✅ result1 자동 로드
# ✅ 로그 파일: logs/structure.log

# 3단계: 콘텐츠 생성
result3 = await execute_phase("content")
# 🚨 여기서 실패!

# 문제 수정 후...
result3 = await retry_phase("content")  # ✅ 3단계만 재실행!
# ✅ Phase 1-2 재실행 불필요
# ✅ 비용/시간 절약
# ✅ 로그로 정확한 원인 파악

# 4단계: 디자인 적용
result4 = await execute_phase("design")

# 5단계: 품질 검토
result5 = await execute_phase("review")
```

---

## 💡 장점 분석

### 1. 🔍 디버깅 용이성
```
Before: "어디서 실패했지? 🤔"
After:  "logs/content.log 확인 → 정확한 에러 라인 파악 ✅"
```

### 2. 💰 비용 절감
```
Before: Phase 3 실패 → 전체 재실행 → $5.00
After:  Phase 3 실패 → Phase 3만 재실행 → $1.00 (80% 절약!)
```

### 3. ⚡ 개발 속도
```
Before: 전체 실행 후 확인 (5분 대기)
After:  Phase 1만 실행 (30초) → 즉시 검증 → 다음 단계
```

### 4. 📊 성능 분석
```
# 각 Phase별 실행 시간 측정 가능
Phase 1 (analyze):    2.3초
Phase 2 (structure):  1.8초
Phase 3 (content):    15.2초  ← 병목 발견!
Phase 4 (design):     3.1초
Phase 5 (review):     2.4초
```

### 5. 🎯 선택적 실행
```python
# 시나리오: 디자인만 변경하고 싶을 때
await execute_phase("design", force=True)  # 1-3단계 건너뛰기
await execute_phase("review")

# 기존: 전체 5단계 실행 필요 (5분)
# 개선: 2단계만 실행 (1분)
```

---

## 🎯 클로드 코드 실행 가이드

### Step 1: 프로젝트 확인
```bash
cd D:\PPT_Designer_OK
pwd  # 현재 위치 확인
```

### Step 2: StateManager 생성
```bash
# 파일 생성
cat > app/core/state_manager.py

# 위에 제공된 StateManager 코드 복사/붙여넣기
```

### Step 3: PhaseManager 생성
```bash
# 파일 생성
cat > app/core/phase_manager.py

# 위에 제공된 PhaseManager 코드 복사/붙여넣기
```

### Step 4: API 엔드포인트 생성
```bash
# 디렉토리 생성
mkdir -p app/api/v1

# 파일 생성
cat > app/api/v1/phase_endpoints.py

# 위에 제공된 API 코드 복사/붙여넣기
```

### Step 5: PhaseLogger 생성
```bash
cat > app/core/phase_logger.py
# 위에 제공된 Logger 코드 복사/붙여넣기
```

### Step 6: 테스트
```bash
# 기본 테스트
pytest tests/test_phase_separation.py -v

# API 서버 실행
python -m uvicorn app.main:app --reload

# API 테스트
curl -X POST http://localhost:8000/api/v1/phases/execute \
  -H "Content-Type: application/json" \
  -d '{"project_id": "test123", "phase": "analyze"}'
```

---

## ❓ 결론: 단계별 분리를 해야 할까?

### ✅ **강력 추천합니다!**

**이유:**
1. ✅ **Production 환경 필수**: 실제 서비스에서는 반드시 필요
2. ✅ **디버깅 시간 80% 단축**: 문제 위치 즉시 파악
3. ✅ **비용 70% 절감**: 실패 시 해당 단계만 재실행
4. ✅ **개발 속도 3배 향상**: 부분 테스트 가능
5. ✅ **확장성 확보**: 나중에 마이크로서비스 전환 용이

**단점:**
- ❌ 초기 개발 시간 2-3일 추가 소요
- ❌ 코드 복잡도 소폭 증가

**하지만:**
- ✅ 2-3일 투자로 향후 수개월 시간 절약
- ✅ 코드 복잡도보다 유지보수성 향상이 훨씬 큼

---

## 🚀 다음 단계

클로드 코드에게 이렇게 요청하세요:

```
"Task 5.1: 단계별 API 분리 아키텍처 구축을 시작해줘.

1. app/core/state_manager.py 생성
2. app/core/phase_manager.py 생성  
3. app/api/v1/phase_endpoints.py 생성
4. app/core/phase_logger.py 생성
5. tests/test_phase_separation.py 작성

각 파일은 위 작업지시서의 코드를 기반으로 작성하고,
기존 WorkflowOrchestrator와 통합해줘."
```

---

궁금한 점이나 추가로 필요한 설명이 있으면 알려주세요! 🎯